"""
Backlog Item Document Handler

Handles backlog_item documents generated by the Backlog Generator DCW.
Extracts individual backlog items as multi-instance child documents.
"""

from typing import Dict, Any, List, Optional
from app.domain.handlers.base_handler import BaseDocumentHandler
import logging

logger = logging.getLogger(__name__)


class BacklogItemHandler(BaseDocumentHandler):
    """
    Handler for backlog_item document type.

    Processes the Backlog Generator DCW output (a BacklogItemList)
    and spawns individual backlog_item documents via get_child_documents().
    Each item gets instance_id = item['id'] (e.g., 'E001', 'F003').
    """

    @property
    def doc_type_id(self) -> str:
        return "backlog_item"

    def extract_title(self, data: Dict[str, Any], fallback: str = "Untitled") -> str:
        # For the parent list document
        items = data.get("items", [])
        if items:
            epic_count = sum(1 for i in items if i.get("level") == "EPIC")
            feature_count = sum(1 for i in items if i.get("level") == "FEATURE")
            story_count = sum(1 for i in items if i.get("level") == "STORY")
            parts = []
            if epic_count:
                parts.append(f"{epic_count} epics")
            if feature_count:
                parts.append(f"{feature_count} features")
            if story_count:
                parts.append(f"{story_count} stories")
            return f"Backlog: {', '.join(parts)}"

        # For individual item documents
        title = data.get("title", "")
        level = data.get("level", "")
        item_id = data.get("id", "")
        if title and level:
            return f"[{level}] {item_id}: {title}"
        return fallback

    def transform(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Add computed fields for the list document."""
        items = data.get("items", [])
        if items:
            data["epic_count"] = sum(1 for i in items if i.get("level") == "EPIC")
            data["feature_count"] = sum(1 for i in items if i.get("level") == "FEATURE")
            data["story_count"] = sum(1 for i in items if i.get("level") == "STORY")
            data["total_count"] = len(items)
        return data

    def get_child_documents(
        self,
        data: Dict[str, Any],
        parent_title: str
    ) -> List[Dict[str, Any]]:
        """
        Extract individual BacklogItem documents from the list.

        Each item becomes a separate backlog_item document with
        instance_id = item['id'] for multi-instance uniqueness.
        """
        items = data.get("items", [])
        children = []

        for item in items:
            item_id = item.get("id", "")
            level = item.get("level", "EPIC")
            title = item.get("title", "Untitled")

            if not item_id:
                logger.error("BacklogItem missing id - skipping")
                continue

            child_content = {
                "id": item_id,
                "level": level,
                "title": title,
                "description": item.get("description", ""),
                "priority_score": item.get("priority_score", 1),
                "depends_on": item.get("depends_on", []),
                "parent_id": item.get("parent_id"),
                "_lineage": {
                    "parent_document_type": "backlog_item",
                    "parent_execution_id": None,  # Injected by plan_executor
                },
            }

            children.append({
                "doc_type_id": "backlog_item",
                "title": f"[{level}] {item_id}: {title}",
                "content": child_content,
                "identifier": item_id,
            })

        logger.info(f"Extracted {len(children)} backlog items from generator output")
        return children

    def render(self, data: Dict[str, Any], context: Optional[Dict[str, Any]] = None) -> str:
        # Individual item rendering
        item_id = data.get("id", "")
        level = data.get("level", "")
        title = self._escape(data.get("title", ""))
        description = self._escape(data.get("description", ""))
        priority = data.get("priority_score", "")
        depends = data.get("depends_on", [])
        parent = data.get("parent_id") or "None"

        deps_html = ", ".join(self._escape(d) for d in depends) if depends else "None"

        return f"""
        <div class="space-y-3">
            <div class="flex items-center gap-2">
                <span class="px-2 py-0.5 text-xs font-medium rounded bg-blue-100 text-blue-800">{level}</span>
                <span class="font-mono text-sm text-indigo-600">{self._escape(item_id)}</span>
                <span class="text-sm font-medium">{title}</span>
            </div>
            <p class="text-sm whitespace-pre-wrap">{description}</p>
            <div class="flex gap-4 text-sm text-gray-500">
                <span>Priority: <strong>{priority}</strong></span>
                <span>Parent: <strong>{self._escape(parent)}</strong></span>
                <span>Depends on: <strong>{deps_html}</strong></span>
            </div>
        </div>
        """

    def render_summary(self, data: Dict[str, Any], context: Optional[Dict[str, Any]] = None) -> str:
        item_id = data.get("id", "")
        level = data.get("level", "")
        title = self._escape(data.get("title", ""))
        priority = data.get("priority_score", "")
        return f"[{level}] {self._escape(item_id)}: {title} (P{priority})"
