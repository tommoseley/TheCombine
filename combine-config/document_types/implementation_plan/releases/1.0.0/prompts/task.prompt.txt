# Task: Implementation Plan (Final)

Triggering Instruction

You are operating under a certified role prompt.
This task prompt defines only the current task.
Do not modify role identity, authority, or internal reasoning structures.

## Task Objective

Produce the Final Implementation Plan by reconciling Primary Implementation Plan
WP candidates into committed Work Packages, informed by Technical Architecture
decisions and constraints.

This document is the authoritative plan that spawns Work Package child documents for execution.
Every committed Work Package in this plan will become a governed artifact with governance pinning.

## Inputs Provided

You will receive exactly two input documents:

* Primary Implementation Plan - contains work_package_candidates[] with candidate_ids (WPC-001, WPC-002, etc.)
* Technical Architecture - contains architecture decisions, constraints, and component definitions

These are the ONLY sources of requirements. No other context may be assumed.

## Candidate-to-WP Traceability (Non-Negotiable)

This is the governance core of this document. The IPF must explicitly account for every
IPP WP candidate. No candidate may silently disappear or be silently invented.

### Rules

1. Every IPP candidate_id MUST appear exactly once in candidate_reconciliation[].
2. Every candidate_reconciliation entry MUST have an outcome: kept, split, merged, or dropped.
3. If outcome is kept, split, or merged: resulting_wp_ids[] MUST contain at least one valid wp_id.
4. If outcome is dropped: resulting_wp_ids[] MUST be empty. notes MUST explain why.
5. Every committed WP MUST have source_candidate_ids[] referencing the IPP candidates it derives from.
6. Every committed WP MUST have a transformation value: kept, split, merged, or added.
7. If transformation is "added": source_candidate_ids[] MUST be empty. transformation_notes MUST justify the addition with specific architecture constraints or scope changes.
8. If transformation is "kept": source_candidate_ids[] has exactly one entry. The WP preserves the candidate's intent (scope refinement is permitted, not intent change).
9. If transformation is "split": source_candidate_ids[] has exactly one entry. Multiple WPs share the same source.
10. If transformation is "merged": source_candidate_ids[] has two or more entries.

### Referential Consistency

* The set of all candidate_ids in candidate_reconciliation[] must equal the set of all candidate_ids from the IPP input.
* The set of all resulting_wp_ids across candidate_reconciliation[] must be a subset of wp_ids in work_packages[].
* The set of all source_candidate_ids across work_packages[] must be a subset of candidate_ids from the IPP input.
* No orphan WPs (every WP with transformation != "added" must appear in at least one reconciliation entry).
* No orphan candidates (every IPP candidate must have a reconciliation entry).

## Scope Rules

You MUST:
* Start from IPP WP candidates as the baseline - these are the scope foundation
* Use Technical Architecture to inform dependencies and governance pinning
* Preserve candidate intent unless architecture review forces splitting, merging, or dropping
* Document every transformation with rationale in transformation_notes and reconciliation notes
* Reference specific architecture decisions or constraints when justifying changes
* Pin governance references (ta_version_id, applicable ADR and policy refs) on each WP

You MUST NOT:
* Invent new WPs unless Technical Architecture reveals a gap that no existing candidate covers
* Silently drop, rename, or restructure candidates without reconciliation entries
* Decompose WPs into features, stories, tasks, or implementation detail
* Assign estimates, timelines, or ownership
* Imply delivery commitment beyond scope definition
* Introduce solution design beyond what the Technical Architecture provides

## Work Package Requirements

Each committed Work Package must include:
* wp_id - unique, snake_case (e.g., "document_registry")
* title - human-readable
* rationale - why this WP is needed
* scope_in - explicit scope items
* scope_out - explicit exclusions
* dependencies - references to other wp_ids with dependency_type and notes
* definition_of_done - measurable completion criteria
* governance_pins - governance references:
  * ta_version_id - Technical Architecture version (required, non-empty)
  * adr_refs - applicable ADR IDs (may be empty)
  * policy_refs - applicable policy IDs (may be empty)
* transformation - how it relates to IPP candidates (kept, split, merged, added)
* source_candidate_ids - IPP candidate IDs it derives from (WPC-001 format)
* transformation_notes - justification for the transformation

## Plan Summary

The plan_summary must include:
* overall_intent - what this plan aims to achieve
* mvp_definition - what constitutes MVP
* key_constraints - constraints shaping the plan
* sequencing_rationale - why Work Packages are ordered this way

## Additional Sections

* cross_cutting_concerns - concerns spanning multiple Work Packages
* meta - provenance block (schema_version: "1.0", artifact_id, created_at, source: "combine_generated")

System will overwrite meta.created_at and meta.artifact_id with system values.

## Output Rules

* Output valid JSON only
* Follow the Implementation Plan schema exactly
* All arrays must be present even if empty
* Never output null
* No commentary, markdown, or explanation outside JSON
* additionalProperties is false at every level - do not add extra fields

## Governance & Audit Constraints

* All WPs must be traceable to IPP candidates via source_candidate_ids
* All IPP candidates must be accounted for via candidate_reconciliation
* All WPs must have governance_pins with ta_version_id populated
* No implicit decisions or silent interpretations
* Any uncertainty must be explicitly stated
* Output must be fully loggable and replayable per ADR-010
* No bypassing of audit, QA, or traceability mechanisms per ADR-009

## Determinism & Replay Readiness

Given identical inputs, the task should:
* Produce equivalent WPs with equivalent scope and intent
* Preserve semantic meaning across runs
* Maintain stable wp_ids when candidate meaning is preserved
* Avoid stylistic variance that alters interpretation
* Contain no references to time, prior executions, or external state

## Final Self-Check Before Output

1. JSON parses correctly
2. All required fields present at every level
3. meta block present with schema_version "1.0"
4. Every IPP candidate_id appears in candidate_reconciliation[]
5. Every reconciliation entry has valid resulting_wp_ids (or empty if dropped)
6. Every WP has source_candidate_ids and transformation
7. Referential consistency: reconciliation wp_ids exist in work_packages[]
8. WP IDs are unique and snake_case
9. Dependencies reference valid WP IDs only
10. governance_pins.ta_version_id is populated on every WP
11. No additional properties at any level

## Failure Conditions (Automatic Reject)

This task fails if:
* Any IPP candidate is missing from candidate_reconciliation
* Any WP with transformation != "added" has empty source_candidate_ids
* Any WP has empty or missing governance_pins.ta_version_id
* Orphan references exist (wp_ids or candidate_ids that don't resolve)
* Role identity or authority is restated or altered
* Stories, tasks, features, or implementation detail appear
* Estimation, scheduling, or ownership is introduced
* Output depends on unstated context or prior runs
* Epic candidates or Epics appear (output must use Work Package candidates only)
