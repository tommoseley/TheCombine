{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://thecombine.dev/schemas/qa_semantic_compliance_output.v1.json",
  "title": "QASemanticComplianceOutputV1",
  "description": "Output contract for Layer 2 LLM-based semantic QA validation. The LLM evaluates every bound constraint exactly once and returns a machine-parseable compliance report with coverage status, findings, and an overall gate decision.",
  "type": "object",
  "additionalProperties": false,
  "required": [
    "schema_version",
    "correlation_id",
    "gate",
    "summary",
    "coverage",
    "findings"
  ],
  "properties": {
    "schema_version": {
      "type": "string",
      "const": "qa_semantic_compliance_output.v1"
    },
    "correlation_id": {
      "type": "string",
      "minLength": 1,
      "description": "Workflow correlation id for traceability."
    },
    "gate": {
      "type": "string",
      "enum": ["pass", "fail"],
      "description": "Overall semantic QA gate decision. MUST be 'fail' if any coverage item has status 'contradicted' or 'reopened'."
    },
    "summary": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "errors",
        "warnings",
        "infos",
        "expected_constraints",
        "evaluated_constraints",
        "blocked_reasons"
      ],
      "properties": {
        "errors": {
          "type": "integer",
          "minimum": 0,
          "description": "Count of findings with severity 'error'."
        },
        "warnings": {
          "type": "integer",
          "minimum": 0,
          "description": "Count of findings with severity 'warning'."
        },
        "infos": {
          "type": "integer",
          "minimum": 0,
          "description": "Count of findings with severity 'info'."
        },
        "expected_constraints": {
          "type": "integer",
          "minimum": 0,
          "description": "Count of bound constraints provided to the semantic QA call. MUST equal coverage.expected_count."
        },
        "evaluated_constraints": {
          "type": "integer",
          "minimum": 0,
          "description": "Count of coverage items with status != 'not_evaluated'. MUST equal coverage.evaluated_count."
        },
        "blocked_reasons": {
          "type": "array",
          "description": "Human-readable reasons gate failed (if any). Empty array if gate = 'pass'.",
          "items": {
            "type": "string",
            "minLength": 1
          }
        }
      }
    },
    "coverage": {
      "type": "object",
      "additionalProperties": false,
      "required": ["expected_count", "evaluated_count", "items"],
      "description": "Per-bound-constraint evaluation status. Exactly one item per bound constraint id.",
      "properties": {
        "expected_count": {
          "type": "integer",
          "minimum": 0,
          "description": "MUST equal the number of bound constraints provided to the semantic QA call."
        },
        "evaluated_count": {
          "type": "integer",
          "minimum": 0,
          "description": "MUST equal count of items where status != 'not_evaluated'."
        },
        "items": {
          "type": "array",
          "minItems": 0,
          "description": "One entry per bound constraint. Order should match input order.",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": ["constraint_id", "status"],
            "properties": {
              "constraint_id": {
                "type": "string",
                "minLength": 1,
                "description": "Stable bound constraint / PGC question id (e.g., PLATFORM_TARGET). MUST match one of the provided constraint ids."
              },
              "status": {
                "type": "string",
                "enum": [
                  "satisfied",
                  "missing",
                  "contradicted",
                  "reopened",
                  "not_evaluated"
                ],
                "description": "Semantic evaluation outcome. 'satisfied' = constraint honored. 'missing' = not stated. 'contradicted' = directly violated. 'reopened' = decision questioned/challenged. 'not_evaluated' = ambiguous/malformed/cannot classify."
              },
              "evidence_pointers": {
                "type": "array",
                "minItems": 0,
                "items": {
                  "type": "string",
                  "minLength": 1
                },
                "description": "JSONPath pointers to evidence locations. Prefer document paths: $.known_constraints[0].constraint, $.unknowns[2].question, $.assumptions[1].assumption. May reference $.pgc_questions[...] or $.invariants[...] if needed."
              },
              "notes": {
                "type": "string",
                "maxLength": 300,
                "description": "Optional short note explaining ambiguous cases or why not_evaluated."
              }
            }
          }
        }
      }
    },
    "findings": {
      "type": "array",
      "minItems": 0,
      "description": "Violations and issues found. Each finding MUST correspond to a coverage item status or policy check.",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "severity",
          "code",
          "constraint_id",
          "message",
          "evidence_pointers"
        ],
        "properties": {
          "severity": {
            "type": "string",
            "enum": ["error", "warning", "info"],
            "description": "'error' blocks the gate. 'warning' and 'info' are advisory."
          },
          "code": {
            "type": "string",
            "enum": [
              "BOUND_CONTRADICTION",
              "BOUND_REOPENED",
              "BOUND_MISSING_EXPLICIT",
              "PROMOTION_RULE_VIOLATION",
              "INVENTED_CONSTRAINT",
              "TRACEABILITY_GAP",
              "OTHER"
            ],
            "description": "Finding type code. BOUND_CONTRADICTION = constraint directly violated. BOUND_REOPENED = decision questioned/challenged. BOUND_MISSING_EXPLICIT = required constraint not stated. PROMOTION_RULE_VIOLATION = should-answer promoted to constraint. INVENTED_CONSTRAINT = constraint not traceable to input. TRACEABILITY_GAP = cannot evaluate. OTHER = edge cases only."
          },
          "constraint_id": {
            "type": "string",
            "minLength": 1,
            "description": "MUST match one of the provided bound constraint ids. No hallucinated ids allowed."
          },
          "message": {
            "type": "string",
            "minLength": 1,
            "maxLength": 200,
            "description": "Concise actionable message describing the issue."
          },
          "evidence_pointers": {
            "type": "array",
            "minItems": 1,
            "items": {
              "type": "string",
              "minLength": 1
            },
            "description": "One or more JSONPath pointers showing where the issue is evidenced. Required for all findings."
          },
          "suggested_fix": {
            "type": "string",
            "maxLength": 300,
            "description": "Optional remediation hint for the remediation node."
          }
        }
      }
    },
    "meta": {
      "type": "object",
      "additionalProperties": false,
      "description": "Optional metadata for governance and debugging.",
      "properties": {
        "model": {
          "type": "string",
          "description": "LLM model used for semantic QA."
        },
        "prompt_version": {
          "type": "string",
          "description": "Version of the semantic QA prompt."
        },
        "policy_version": {
          "type": "string",
          "description": "Version of the policy rules applied."
        },
        "run_id": {
          "type": "string",
          "description": "Unique identifier for this QA run."
        },
        "latency_ms": {
          "type": "integer",
          "minimum": 0,
          "description": "LLM call latency in milliseconds."
        },
        "input_tokens": {
          "type": "integer",
          "minimum": 0,
          "description": "Token count for LLM input."
        },
        "output_tokens": {
          "type": "integer",
          "minimum": 0,
          "description": "Token count for LLM output."
        }
      }
    }
  }
}
