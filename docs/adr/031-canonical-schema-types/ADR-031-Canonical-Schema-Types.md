# ADR-031: Canonical Schema Types and DB-Backed Schema Registry

| | |
|---|---|
| **Status** | Draft |
| **Date** | 2026-01-06 |
| **Decision Owner** | Product Owner |
| **Applies To** | All schema-governed generation, validation, and UI composition |
| **Related Artifacts** | ADR-010, ADR-012, ADR-028, ADR-029, POL-WS-001, (future) ADR-032 |

---

## 1. Context

The Combine produces governed, auditable outputs driven by schemas. We are standardizing JSON "content blocks" (e.g., questions, risks, scope lists) so they can be:

- reused across document types,
- validated mechanically,
- generated by LLMs using deterministic contracts, and
- rendered later by fragment-based UI composition.

**Current issues:**

- Similar JSON sections (e.g., "questions") exist in multiple schemas with incompatible shapes.
- Schema reuse is informal (copy/paste), leading to drift.
- `$ref` usage assumes filesystem access, which is incompatible with DB-governed artifacts.
- LLMs cannot resolve paths or retrieve external artifacts.
- Execution logging (ADR-010) does not yet capture schema bundle identity.

We require canonical reuse, deterministic resolution, and auditable schema usage.

---

## 2. Decision

### 2.1 Canonical Schema Types Exist and Are Reused

The Combine will maintain a library of canonical schema types (e.g., `OpenQuestionV1`, `RiskV1`) as governed artifacts.

Document schemas **MUST** reuse canonical types via `$ref` rather than re-defining equivalent structures inline.

**Hard rule (law):**

> No new document schema may introduce a novel shape for a content block if an equivalent canonical type exists. It must reuse the canonical type via `$ref`.

**Equivalence determination:**

Equivalence is determined through governance review (human QA/approver), not self-declared by contributors.

**Guidance:**

When in doubt, create a new canonical type with a distinct name rather than force-fitting into an existing type.

### 2.2 Schemas Are Stored and Governed in the Database

All schemas used for LLM generation, validation, and UI composition **MUST** be stored as governed artifacts in the database.

Filesystem access is **not permitted** for schema resolution during LLM request construction.

Schemas embedded elsewhere (e.g., document type records or prompts) are considered legacy and must be migrated under governance.

### 2.3 $ref Targets Use Schema IDs, Not File Paths

All internal schema references **MUST** use explicit schema identifiers:

```
$ref: "schema:<SchemaId>"
```

Examples:

- `schema:OpenQuestionV1`
- `schema:RiskV1`

File paths (e.g., `seed/schemas/...`) **MUST NOT** appear in runtime schemas or LLM-bound payloads.

### 2.4 Schema Registry and Resolver Produce Resolved Bundles

A **Schema Registry** capability provides retrieval and governance over DB-stored schemas.

A **SchemaResolver** will:

1. Accept a `root_schema_id`
2. Retrieve the root schema from the DB
3. Recursively resolve all `$ref: "schema:<id>"` references from the DB
4. Produce a **Resolved Schema Bundle** suitable for:
   - LLM generation
   - Mechanical validation
   - Audit and replay

**Resolver rules:**

- Circular references are **not allowed** and must be rejected.
- Only schemas with `status=accepted` may be used for LLM generation.

**LLM requests MUST include resolved bundles only.**

No unresolved `$ref`, schema IDs, or locators may be passed to the model.

### 2.5 Schema Bundles Are Hashed and Logged for Auditability

Every resolved bundle must include:

- `root_schema_id`
- `bundle_sha256` (hash of the resolved schema payload)
- `dependency list` (schema IDs + individual hashes)

Per ADR-010, LLM execution logging **MUST** record at minimum:

- `root_schema_id`
- `bundle_sha256`

This enables deterministic replay and traceability.

### 2.6 Display Metadata Is Allowed (Schema-Governed)

Document schemas may include display-oriented metadata required for deterministic viewing and composition using a namespaced extension:

```
x-combine-view
```

This metadata may define ordering, titles, and visibility rules for sections, but **MUST NOT** embed styling or bespoke UI logic.

(Fragment rendering and viewer behavior are defined in ADR-032.)

---

## 3. Consequences

### Positive

- Eliminates schema drift across shared content blocks
- Enables schema-driven UI composition
- Produces deterministic, self-contained LLM inputs
- Strengthens auditability and replay
- Decouples runtime behavior from filesystem state

### Trade-offs

- Requires schema lifecycle governance (draft → accepted → deprecated)
- Introduces resolver complexity
- Adds intentional friction to introduce new shapes

---

## 4. Implementation Notes (Non-Normative)

A minimal schema registry typically includes:

**schema_artifact**

- `schema_id`
- `version`
- `status` (draft / accepted / deprecated)
- `schema_json`
- `sha256`
- `governance_refs` (ADRs, policies)

**SchemaResolver.resolve_bundle(root_schema_id)**

- returns bundled schema
- bundle hash
- dependency list

---

## 5. Migration Path (Non-Normative)

Existing schemas embedded in:

- `document_types.schema_definition` (JSONB)
- task prompts or templates

will be migrated incrementally.

During transition:

- New canonical types are created in the registry
- Document schemas are updated to reference canonical types via `$ref`
- Legacy inline definitions remain valid until explicitly migrated
- Migration activities are governed by Work Statements per POL-WS-001

---

## 6. Acceptance Criteria

ADR-031 is considered satisfied when:

1. A DB-backed `schema_artifact` store exists with:
   - `schema_id`
   - `version`
   - `status`
   - canonical schema JSON
   - `sha256` hash

2. `$ref: "schema:<SchemaId>"` references are supported and resolved by SchemaResolver.

3. Circular schema references are detected and rejected.

4. At least one canonical type (e.g., `OpenQuestionV1`) is seeded and marked `accepted`.

5. A resolved schema bundle can be produced for at least one document schema that depends on a canonical type.

6. LLM callers receive only resolved schema bundles (no filesystem access, no unresolved `$ref`).

7. LLM execution logs include `root_schema_id` and `bundle_sha256`.

---

## 7. Out of Scope

- Fragment registry and fragment-based document viewer composition (ADR-032)
- Styling systems and UI tokens
- Schema authoring UI
- Cross-field membership validation beyond JSON Schema (handled by mechanical validators)

---

*End of ADR-031*