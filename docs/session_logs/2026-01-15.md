# Session Summary - 2026-01-15

## Scope
- ADR-037 and ADR-038 acceptance and documentation
- Reference workflow plans review and expansion
- Circuit breaker policy decision
- Cyclomatic complexity analysis

## Decisions Made
- ADR-037 (Concierge-Constrained Workflow Routing) accepted
- ADR-038 (Workflow Plan Schema) accepted
- Circuit breaker policy: engine-owned, not plan-owned (max_retries = 2 for MVP)
- QA failure edges added to reference workflow plans (auto rework pattern)

## Implemented
- ADR-037 written to docs/adr/ADR-037-concierge-constrained-workflow-routing.md
- ADR-038 written to docs/adr/ADR-038-workflow-plan-schema.md
- Both ADRs include circuit breaker implementation notes
- ADR-038 Non-Goals updated to exclude retry counters from plan schema

## Updated or Created
- docs/adr/ADR-037-concierge-constrained-workflow-routing.md (new)
- docs/adr/ADR-038-workflow-plan-schema.md (new)

## Commits / PRs
- None (pending user commit)

## Open Threads
- Reference workflow plans (software_development, business_plan) documented but not yet seeded to database
- Cyclomatic complexity refactoring identified but not started

## Known Risks / Drift Warnings
- None

---

## Cyclomatic Complexity Report

### Executive Summary

Highest complexity is concentrated in 6 files, primarily in the domain services layer. The main culprits are large functions handling multiple code paths (shape handlers, streaming logic, UI rendering).

### Top 10 Most Complex Functions (by size + branching)

| Rank | File | Function | Lines | Issue |
|------|------|----------|-------|-------|
| 1 | document_builder.py | build_stream | 289 | Streaming + error handling + state management |
| 2 | document_routes.py | get_document | 250 | Multiple document type branches + rendering |
| 3 | story_backlog_service.py | generate_epic_stories | 244 | LLM orchestration + validation + storage |
| 4 | render_model_builder.py | _process_section | 216 | 5 shape handlers in one function |
| 5 | document_builder.py | build | 204 | Similar to build_stream, non-streaming |
| 6 | auth/service.py | get_or_create_user_from_oidc | 186 | OAuth flow + user creation + linking |
| 7 | admin/pages.py | execution_detail | 180 | UI assembly for workflow executions |
| 8 | admin/pages.py | executions_list | 138 | Filtering + pagination + status mapping |
| 9 | story_backlog_service.py | generate_all_stories | 134 | Orchestration over multiple epics |
| 10 | document_routes.py | _render_with_new_viewer | 111 | Template selection + data assembly |

### File-Level Complexity Summary

| File | Lines | Complexity Score | Primary Issue |
|------|-------|------------------|---------------|
| seed_fragment_artifacts.py | 1196 | 174 | Large data definition file |
| render_model_builder.py | 859 | 160 | Shape dispatch in _process_section |
| story_backlog_service.py | 793 | 149 | LLM orchestration sprawl |
| admin/pages.py | 734 | 106 | Route handlers doing too much |
| document_builder.py | 749 | 99 | Duplicated streaming/non-streaming logic |
| document_routes.py | 578 | 91 | Business logic in routes |
| project_discovery_handler.py | 614 | 84 | Many render helper methods |
| validator.py | 555 | 80 | Many validation sub-methods |

### Patterns Causing Complexity

#### 1. Shape Dispatch in _process_section (render_model_builder.py:484-699)

The function handles 5 different shapes with if/elif chains:
- single
- list
- nested_list
- container
- derived (via separate method)

Fix: Extract each shape handler to a separate method. Use a dispatch dict.

#### 2. Parallel Non-Streaming/Streaming Code (document_builder.py)

- build() = 204 lines
- build_stream() = 289 lines
- These are ~70% duplicated logic with streaming vs non-streaming differences.

Fix: Extract shared logic to private methods; have build and build_stream compose them.

#### 3. God Functions in Routes (document_routes.py, admin/pages.py)

- get_document (250 lines) handles: auth, lookup, type detection, rendering selection, error handling
- execution_detail (180 lines) assembles complex UI state

Fix: Move business logic to services; routes become thin orchestration.

#### 4. OAuth Monster (auth/service.py:get_or_create_user_from_oidc)

186 lines handling: user lookup, creation, identity linking, session creation, error recovery

Fix: Break into: _find_existing_user, _create_new_user, _link_identity, _create_session

#### 5. LLM Orchestration Functions (story_backlog_service.py)

Multiple long functions with interleaved: input gathering, LLM calls, output parsing, storage

Fix: Apply handler pattern more consistently; separate concerns.

### Recommended Refactoring Priority

| Priority | File | Target | Estimated Effort |
|----------|------|--------|------------------|
| P1 | render_model_builder.py | _process_section -> shape handlers | 2 hours |
| P1 | document_builder.py | Extract shared logic from build/build_stream | 3 hours |
| P2 | auth/service.py | Split get_or_create_user_from_oidc | 1.5 hours |
| P2 | document_routes.py | Move logic from get_document to service | 2 hours |
| P3 | admin/pages.py | Extract execution_detail UI assembly | 2 hours |
| P3 | story_backlog_service.py | Consolidate LLM orchestration patterns | 3 hours |

### Quick Wins (Under 1 Hour Each)

1. _process_section shape dispatch - Extract 4 methods, add dispatch dict
2. _validate_type in output_parser.py - 68 lines of type checking, could be table-driven
3. safe_len in render_model_builder.py - 68 lines, appears to be a utility that grew