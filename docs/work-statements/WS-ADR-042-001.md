# WS-ADR-042-001: Constraint Binding Implementation

**Status:** ✅ Complete
**Created:** 2026-01-24
**Completed:** 2026-01-24
**Scope:** Multi-commit (schema + engine + validation)
**ADR:** ADR-042 (Accepted)

---

## Governing References

- **ADR-042**: Constraint Binding & Cross-Node Drift Enforcement
- **ADR-024**: Clarification Question Protocol
- **ADR-014**: Quality Assurance Modes & Authority
- **WS-PGC-VALIDATION-001**: Code-based validation (pattern to follow)

---

## Preconditions

- [x] ADR-042 accepted
- [x] PGC workflow functional (questions generated, answers collected)
- [x] `pgc_answers` table exists (stores both questions AND answers)
- [x] QA node with code-based validation operational

---

## Purpose

Implement ADR-042's constraint binding system so that:
1. PGC questions and answers are merged into `pgc_clarifications`
2. Binding status is derived mechanically (no LLM, no NLP)
3. Bound constraints propagate to ALL downstream nodes
4. ALL QA nodes enforce constraint drift checks

This closes the gap where the generator sees answers but not questions, causing drift.

---

## Implementation Phases

### Phase 1: Schema Definition

**File:** `seed/schemas/pgc_clarifications.v1.json`

Define canonical schema for merged clarifications:

```json
{
  "id": "TARGET_PLATFORM",
  "text": "What platform should the app target?",
  "priority": "must",
  "answer_type": "single_choice",
  "constraint_kind": "selection",
  "choices": [
    { "id": "web", "label": "Web browser" },
    { "id": "mobile", "label": "Mobile application" }
  ],
  "user_answer": "web",
  "user_answer_label": "Web browser",
  "resolved": true,
  "binding": true,
  "binding_source": "priority",
  "binding_reason": "must-priority question with resolved answer"
}
```

**New fields for binding derivation:**

| Field | Type | Purpose |
|-------|------|---------|
| `constraint_kind` | enum | Schema-level hint: `"selection"`, `"exclusion"`, `"requirement"`, `"preference"` |
| `binding_source` | enum | Why binding: `"priority"`, `"exclusion"`, `"user_marked"`, `"system"` |
| `binding_reason` | string | Human-readable explanation for QA messages and telemetry |

**constraint_kind values:**
- `selection`: User picks from options (binding if must-priority)
- `exclusion`: User explicitly excludes something (always binding if resolved)
- `requirement`: User states a hard requirement (always binding if resolved)
- `preference`: User states a preference (never binding)

### Phase 2: Mechanical Merge Function

**File:** `app/domain/workflow/clarification_merger.py`

Functions:
- `merge_clarifications(questions, answers)` -> List of merged clarifications
- `extract_invariants(clarifications)` -> List where binding=true

**Binding derivation rules (DETERMINISTIC - no NLP, no regex on English):**

```python
def _derive_binding(question: dict, answer: Any, resolved: bool) -> tuple[bool, str, str]:
    """
    Returns: (binding, binding_source, binding_reason)
    
    Rules per ADR-042 Section 3 (in order of precedence):
    1. Not resolved -> binding=False
    2. constraint_kind == "exclusion" AND resolved -> binding=True
    3. constraint_kind == "requirement" AND resolved -> binding=True
    4. priority == "must" AND resolved -> binding=True
    5. Otherwise -> binding=False
    """
    if not resolved:
        return False, None, "not resolved"
    
    # Check explicit constraint_kind from question schema (preferred)
    constraint_kind = question.get("constraint_kind", "selection")
    
    if constraint_kind == "exclusion":
        return True, "exclusion", "explicit exclusion constraint"
    
    if constraint_kind == "requirement":
        return True, "requirement", "explicit requirement constraint"
    
    # Priority-based binding
    priority = question.get("priority", "could")
    if priority == "must":
        return True, "priority", "must-priority question with resolved answer"
    
    return False, None, f"{priority}-priority is informational only"
```

**Key principle:** Binding is derived from schema fields (`constraint_kind`, `priority`), NOT from parsing question text. No regex on English prose.

### Phase 3: Question Persistence (Critical)

**Requirement:** Questions must be available at merge time, even after process restart.

The `pgc_answers` table already stores questions alongside answers. The merge function MUST:
1. First try to get questions from `state.pending_user_input_payload`
2. If not present (e.g., after restart), load from `pgc_answers` table via repository

```python
# In plan_executor.py:
questions = state.pending_user_input_payload.get("questions", []) if state.pending_user_input_payload else []

if not questions:
    # Fallback: load from DB (handles restart scenario)
    pgc_record = await pgc_answer_repo.get_by_execution_id(state.execution_id)
    questions = pgc_record.questions if pgc_record else []
    logger.info(f"ADR-042: Loaded {len(questions)} questions from DB fallback")
```

This ensures "works in-memory, fails on reload" bugs are avoided.

### Phase 4: Integration into Plan Executor

**File:** `app/domain/workflow/plan_executor.py`

On PGC submission (when user answers are received):

```python
if current_node.type == NodeType.PGC and user_input:
    logger.info(f"PGC node {current_node.node_id} received user answers - merging clarifications")
    
    # ADR-042: Get questions (with DB fallback for restart scenarios)
    questions = state.pending_user_input_payload.get("questions", []) if state.pending_user_input_payload else []
    if not questions:
        pgc_record = await pgc_answer_repo.get_by_execution_id(state.execution_id)
        questions = pgc_record.questions if pgc_record else []
    
    from app.domain.workflow.clarification_merger import merge_clarifications, extract_invariants
    
    clarifications = merge_clarifications(questions, user_input)
    invariants = extract_invariants(clarifications)
    
    state.update_context_state({
        "pgc_answers": user_input,  # backward compat
        "pgc_clarifications": clarifications,  # ADR-042: Full merged structure
        "pgc_invariants": invariants,  # ADR-042: Binding constraints only
    })
    
    logger.info(f"ADR-042: Merged {len(clarifications)} clarifications, {len(invariants)} binding invariants")
```

### Phase 5: Constraint Drift Validator

**File:** `app/domain/workflow/validation/constraint_drift_validator.py`

**Validator Contract:**

```python
class ConstraintDriftValidator:
    def validate(
        self,
        artifact: Dict[str, Any],  # Parsed JSON artifact (already schema-validated)
        invariants: List[Dict[str, Any]],  # Full pgc_invariants objects
    ) -> DriftValidationResult:
        """
        artifact: The generated artifact as a parsed dict. Must be valid JSON
                  that conforms to its document type schema.
        
        invariants: List of FULL merged clarification objects where binding=true.
                    Each contains: id, text, user_answer, user_answer_label,
                    binding_source, binding_reason (for error messages).
        """
```

**QA Check IDs:**

| Check ID | Severity | Rule |
|----------|----------|------|
| QA-PGC-001 | ERROR | Artifact must not contradict resolved clarifications |
| QA-PGC-002 | ERROR | Resolved clarifications must not appear as open decisions |
| QA-PGC-003 | WARNING | Bound constraints must be stated or implied in artifact |
| QA-PGC-004 | WARNING | Bound constraints should be traceable in known_constraints |

**QA-PGC-003 (New):** Detects when artifact silently omits a binding constraint. Different from contradiction - this catches "forgetting" rather than "contradicting."

```python
def _check_constraint_stated(artifact: dict, invariant: dict) -> Optional[DriftViolation]:
    """
    QA-PGC-003: Bound constraint must be stated or implied.
    
    Fail if: binding constraint value/label not mentioned anywhere in artifact.
    """
    artifact_text = json.dumps(artifact).lower()
    answer_label = invariant.get("user_answer_label") or str(invariant.get("user_answer", ""))
    
    if answer_label.lower() not in artifact_text:
        return DriftViolation(
            check_id="QA-PGC-003",
            severity="WARNING",
            clarification_id=invariant["id"],
            message=f"Bound constraint '{invariant['id']}' ({answer_label}) not stated in artifact",
            remediation="Reference this constraint in known_constraints or summary.",
        )
    return None
```

### Phase 6: QA Node Integration

**File:** `app/domain/workflow/nodes/qa.py`

**REQUIREMENT:** ALL QA nodes must validate against `pgc_invariants` if present. This is NOT conditional on document type.

```python
# This runs for EVERY QA evaluation
invariants = context.context_state.get("pgc_invariants", [])

if invariants:
    from app.domain.workflow.validation.constraint_drift_validator import ConstraintDriftValidator
    
    drift_validator = ConstraintDriftValidator()
    drift_result = drift_validator.validate(
        artifact=document_content,  # Dict, already schema-validated
        invariants=invariants,  # Full clarification objects with binding metadata
    )
    
    if not drift_result.passed:
        # ERROR-level violations -> hard failure
        return NodeResult.failed(
            reason=f"Constraint drift detected: {drift_result.error_summary}",
            metadata={"drift_violations": [v.to_dict() for v in drift_result.errors]},
        )
    
    if drift_result.warnings:
        # WARNING-level violations -> log but continue
        logger.warning(f"ADR-042 drift warnings: {[w.to_dict() for w in drift_result.warnings]}")
```

### Phase 7: Generation Node Contract

**REQUIREMENT:** ALL nodes that produce artifacts MUST include `pgc_invariants` in their LLM context.

This is already handled by `TaskNodeExecutor._build_messages()` which includes `context_state` in the prompt. Verify this works correctly.

**Verification step:**
- Add logging to confirm `pgc_clarifications` appears in generation context
- Log format: `"ADR-042: Injecting {n} clarifications ({m} binding) into generation context"`

### Phase 8: Prompt Contract Requirement

**CONTRACT:** ALL task prompts that generate artifacts MUST include a bound constraints section.

**Required section (add to ALL generation task prompts):**
```
## Bound Constraints (ADR-042)

The following constraints are LOCKED based on prior user clarifications.
You MUST NOT contradict, reopen, or present alternatives to these decisions.
You MAY discuss implications and optimize within these constraints.

Bound constraints will be provided in the "Extracted Context" section under
"pgc_clarifications" with binding=true. Treat these as immutable facts.

If a constraint has binding_source="exclusion", the user has explicitly
excluded that option - do not suggest it even as a future consideration.
```

**Files to update (Phase 8):**
- `seed/prompts/tasks/Project Discovery v1.3.txt` -> v1.4

**Note:** This WS updates Project Discovery only. A follow-on task should audit and update all other task prompts with this section.

---

## Files to Create

| File | Purpose |
|------|---------|
| `seed/schemas/pgc_clarifications.v1.json` | Schema with `constraint_kind`, `binding_source`, `binding_reason` |
| `app/domain/workflow/clarification_merger.py` | Mechanical merge with deterministic binding derivation |
| `app/domain/workflow/validation/constraint_drift_validator.py` | QA-PGC-001 through 004 |

## Files to Modify

| File | Change |
|------|--------|
| `app/domain/workflow/plan_executor.py` | Load questions (with DB fallback), merge, propagate |
| `app/domain/workflow/nodes/qa.py` | Add drift validation (unconditional when invariants exist) |
| `seed/prompts/tasks/Project Discovery v1.3.txt` | Update to v1.4 with bound constraints section |
| `seed/schemas/clarification_question_set.v2.json` | Add `constraint_kind` field to question schema |

---

## Acceptance Criteria

- [x] Schema `pgc_clarifications.v1.json` includes `constraint_kind`, `binding_source`, `binding_reason`
- [x] Questions loaded from DB fallback if not in memory (handles restart)
- [x] `binding` derived from schema fields only (no NLP/regex on English)
- [x] `pgc_clarifications` and `pgc_invariants` propagated to ALL downstream nodes
- [x] ALL QA nodes run drift validation when invariants exist
- [x] QA-PGC-001: Contradictions detected and fail QA (ERROR)
- [x] QA-PGC-002: Reopened decisions detected and fail QA (ERROR)
- [x] QA-PGC-003: Silent omissions detected (WARNING)
- [x] QA-PGC-004: Missing traceability detected (WARNING)
- [x] Platform drift bug (the original issue) is caught
- [x] Generation context logged showing clarifications injected

---

## Test Scenarios

### Scenario 1: Platform Contradiction (QA-PGC-002)
1. PGC: TARGET_PLATFORM = web (must, answered)
2. Generator produces EDP with "platform selection" options
3. QA MUST fail with QA-PGC-002

### Scenario 2: Exclusion Violation (QA-PGC-001)
1. PGC: OFFLINE_MODE = false, constraint_kind = "exclusion"
2. Generator recommends offline-first architecture
3. QA MUST fail with QA-PGC-001

### Scenario 3: Silent Omission (QA-PGC-003)
1. PGC: TARGET_PLATFORM = web (binding)
2. Generator produces artifact with no mention of web platform
3. QA SHOULD warn with QA-PGC-003

### Scenario 4: Happy Path
1. PGC: TARGET_PLATFORM = web (binding)
2. Generator locks platform as constraint, discusses hosting/SPA/MPA as downstream decisions
3. QA passes

### Scenario 5: Reload Resilience
1. Submit PGC answers
2. Restart server (clear in-memory state)
3. Resume workflow
4. Verify clarifications still merge correctly (questions loaded from DB)

---

## Prohibited Actions

- Do NOT use LLM to derive binding status
- Do NOT parse question text to detect exclusions (use `constraint_kind`)
- Do NOT use regex on English prose
- Do NOT modify PGC question generation logic
- Do NOT change pgc_answers table schema
- Do NOT remove backward compatibility with pgc_answers
- Do NOT make drift validation conditional on document type

---

## Definition of Done

1. Platform drift bug is caught by code-based validation
2. All QA checks (001-004) implemented with correct severities
3. Binding derivation is fully deterministic (schema fields only)
4. Questions survive process restart (DB fallback works)
5. All acceptance criteria pass
6. Existing tests continue to pass
7. Manual test: PGC answers visible in generation context as merged clarifications

---

## Out of Scope (Future Work)

- Update ALL task prompts with bound constraints section (this WS does PD only)
- Downstream invariant propagation across multi-workflow chains
- Constraint renegotiation mode
- Intake as constraint source (beyond PGC)

---

## Implementation Report

**Completed:** 2026-01-24
**Refined:** 2026-01-24 (Session 2)

### Files Created

| File | Purpose |
|------|---------|
| `seed/schemas/pgc_clarifications.v1.json` | Schema with constraint_kind, binding_source, binding_reason |
| `app/domain/workflow/clarification_merger.py` | Mechanical merge with deterministic binding derivation |
| `app/domain/workflow/validation/constraint_drift_validator.py` | QA-PGC-001 through QA-PGC-004 |
| `seed/prompts/tasks/Project Discovery v1.4.txt` | Prompt with Bound Constraints section |
| `tests/tier1/workflow/validation/test_constraint_drift_validator.py` | 16 drift validation tests (incl. 2 regression tests) |
| `tests/tier1/workflow/test_clarification_merger.py` | 28 merger tests |
| `tests/unit/test_pgc_form_parsing.py` | 8 form parsing tests |

### Files Modified

| File | Change |
|------|--------|
| `app/domain/workflow/plan_executor.py` | Added `_get_pgc_questions_for_merge()`, `_load_pgc_answers_for_qa()`, `_promote_pgc_invariants_to_document()` |
| `app/domain/workflow/nodes/qa.py` | Added `_run_drift_validation()`, validation order: Drift → Promotion → LLM |
| `app/domain/workflow/nodes/task.py` | Added `_render_bound_constraints_summary()` for prominent constraint display |
| `app/domain/workflow/validation/__init__.py` | Export ConstraintDriftValidator, DriftViolation, DriftValidationResult |
| `app/domain/workflow/validation/validation_result.py` | Added DriftViolation, DriftValidationResult classes |
| `app/web/routes/public/workflow_build_routes.py` | Fixed form key parsing (`key[8:-2]` → `key[8:-3]`), added logging |
| `app/web/templates/public/pages/partials/_pgc_questions.html` | Fixed choice value attribute (`c.id` → `c.value or c.id`) |
| `seed/schemas/clarification_question_set.v2.json` | Added optional constraint_kind field |
| `seed/workflows/project_discovery.v1.json` | Updated to v1.8.0, uses v1.4 prompt, added ADR-042 reference |
| `docs/adr/ADR-042-Constraint-Binding-Cross-Node-Drift-Enforcement.md` | Status: Draft → Accepted |

### Test Coverage

- **Drift Validator Tests:** 16 tests (14 original + 2 false positive regression tests)
- **Merger Tests:** 28 tests covering binding derivation, resolution, label lookup, merge flow
- **Form Parsing Tests:** 8 tests for PGC form key/value extraction
- **Total new tests:** 52 (all passing)

### Key Decisions

1. **Validation order:** Drift → Promotion → Schema → LLM (fail fast on bound constraint violations)
2. **Shared types:** DriftViolation/DriftValidationResult added alongside existing Promotion types
3. **constraint_kind:** Optional field with default "selection" (non-breaking addition to v2 schema)
4. **Prompt injection:** Uses existing context_state mechanism (no new token machinery)

### Session 2 Refinements (2026-01-24)

**Issue:** QA-PGC-002 false positives blocking document generation. Words like "educational", "target", "intended" extracted as topics and matched against reopen patterns.

**Fixes applied:**

1. **Bound constraints summary** - Added `_render_bound_constraints_summary()` in `TaskNodeExecutor` to present settled decisions prominently in natural language BEFORE the JSON context dump. This makes constraints "impossible to miss" for the LLM.

2. **pgc_invariants promotion** - Added `_promote_pgc_invariants_to_document()` in `PlanExecutor` to mechanically transform binding constraints into a structured `pgc_invariants[]` section in the output document at completion.

3. **Form parsing fixes:**
   - Multi-choice key extraction: `key[8:-2]` → `key[8:-3]` (suffix `][]` is 3 chars)
   - Choice value attribute: `c.id` → `c.value or c.id` in HTML template

4. **Expanded stopwords** - Added domain terms (educational, deployment, requirement, etc.) to reduce false positives. Noted as technical debt - the stopwords approach is fragile.

**Result:** End-to-end document generation working. QA correctly rejects non-compliant artifacts and accepts compliant ones after remediation.

---

**End of Work Statement**