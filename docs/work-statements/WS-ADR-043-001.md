# WS-ADR-043-001: Production Line Implementation

**Status:** Draft
**Created:** 2026-01-26
**Scope:** Multi-commit (backend + frontend + terminology migration)
**ADR:** ADR-043 (Accepted)

---

## Governing References

- **ADR-043**: The Production Line
- **ADR-042**: Constraint Binding & Cross-Node Drift Enforcement
- **ADR-010**: LLM Execution Logging

---

## Preconditions

- [ ] ADR-043 accepted
- [ ] Workflow execution infrastructure operational
- [ ] Document dependency graph defined in `document_types`
- [ ] Existing admin execution views functional

---

## Purpose

Implement ADR-043's Production Line as the primary operator surface:

1. Real-time visualization of document production across project
2. SSE-based state updates (no polling)
3. Operator Interrupt contract for PGC and halt review
4. [Run Full Line] orchestration across dependency graph
5. Terminology migration from conversational to production language

**Success criteria:** Operator opens the app and thinks "Let's see how the line is doing."

---

## Prohibited Actions

- Using conversational terminology (generate, retry, failed, error) in new code
- Adding spinners without state attribution
- Page navigation for operator interrupts (must be inline)
- Polling for state updates (must use SSE)

---

## Implementation Phases

### Phase 1: Terminology Migration

**Goal:** Establish production vocabulary in codebase before building UI.

**Files to update:**

| Location | Change |
|----------|--------|
| `app/domain/workflow/plan_executor.py` | Rename outcome values, log messages |
| `app/domain/workflow/nodes/*.py` | Update status terminology |
| `seed/workflows/*.json` | Rename node outcomes |
| Logging throughout | Use production terms |

**Terminology map:**

| Old | New | User-Facing Phrasing |
|-----|-----|----------------------|
| generate, generation | assemble, assembly | "Start Production", "Assembling document..." |
| retry, retry_count | remediation, remediation_count | "Remediating (1/2)", "Self-correction in progress" |
| failed, failure | audit_rejected, halted | "Audit rejected", "Production halted" |
| success | stabilized | "Stabilized", "Production complete" |
| pending | queued, blocked | "Queued", "Blocked (awaiting dependencies)" |
| paused | awaiting_operator | "Awaiting operator", "Line stopped: input required" |
| error | halted | "Halted", "Requires review" |

**Verification:** Grep for old terms; none should appear in new code paths.

---

### Phase 2: Production State Model

**Goal:** Define canonical state enum and transitions.

**File:** `app/domain/workflow/production_state.py`

```python
from enum import Enum

class ProductionState(str, Enum):
    QUEUED = "queued"
    BINDING = "binding"
    ASSEMBLING = "assembling"
    AUDITING = "auditing"
    REMEDIATING = "remediating"
    STABILIZED = "stabilized"
    BLOCKED = "blocked"
    AWAITING_OPERATOR = "awaiting_operator"
    HALTED = "halted"
    ESCALATED = "escalated"

class Station(str, Enum):
    BIND = "bind"
    ASM = "asm"
    AUD = "aud"
    REM = "rem"
```

**File:** `app/domain/workflow/state_mapper.py`

Map existing workflow node states to production states:

| Node Type | Node Outcome | Production State |
|-----------|--------------|------------------|
| pgc | needs_user_input | awaiting_operator |
| pgc | success | (advance to next) |
| task | success | (advance to next) |
| qa | success | stabilized (if terminal) |
| qa | failed | remediating |
| (circuit breaker) | blocked | halted |

---

### Phase 3: SSE Event Infrastructure

**Goal:** Push state transitions to connected clients.

**File:** `app/api/v1/production_events.py`

```python
@router.get("/production/events")
async def production_events(
    project_id: str,
    request: Request,
) -> EventSourceResponse:
    """SSE endpoint for production line state updates."""
```

**Events emitted:**

| Event | Payload | Trigger |
|-------|---------|---------|
| `station_transition` | execution_id, document_type, state, station, elapsed_ms | Node completes |
| `line_stopped` | execution_id, document_type, reason, interrupt_id | Awaiting operator |
| `production_complete` | document_type, outcome | Terminal state reached |
| `interrupt_resolved` | interrupt_id, resolution | Operator submits answer |

**File:** `app/domain/workflow/event_publisher.py`

Interface for plan_executor to emit events:

```python
class ProductionEventPublisher:
    async def station_transition(self, execution_id, doc_type, state, station, elapsed_ms): ...
    async def line_stopped(self, execution_id, doc_type, reason, interrupt_id): ...
    async def production_complete(self, doc_type, outcome): ...
```

---

### Phase 4: Project Orchestrator

**Goal:** [Run Full Line] traverses dependency graph, starts documents in order.

**File:** `app/domain/workflow/project_orchestrator.py`

```python
class ProjectOrchestrator:
    async def run_full_line(self, project_id: str) -> str:
        """
        Start production for entire project.

        1. Load document dependency graph
        2. Identify documents with satisfied dependencies
        3. Start production for each (parallel where allowed)
        4. Listen for stabilization events
        5. Start next tier when dependencies clear
        6. Complete when all stabilized or halted
        """
```

**Behaviors:**

- Respects dependency order from `document_types` config
- Parallel execution where dependencies allow
- Continues other tracks when one awaits operator
- Emits aggregate progress events
- Stores orchestration state for resume after crash

---

### Phase 5: Operator Interrupt Registry

**Goal:** Track pending interrupts, enable inline resolution.

**File:** `app/domain/workflow/interrupt_registry.py`

```python
@dataclass
class OperatorInterrupt:
    id: str
    execution_id: str
    document_type: str
    interrupt_type: Literal["clarification", "audit_review", "constraint_conflict"]
    payload: dict  # Questions, halt details, etc.
    created_at: datetime
    resolved_at: Optional[datetime]
    resolution: Optional[dict]

class InterruptRegistry:
    async def register(self, interrupt: OperatorInterrupt) -> str: ...
    async def get_pending(self, project_id: str) -> List[OperatorInterrupt]: ...
    async def resolve(self, interrupt_id: str, resolution: dict) -> None: ...
```

**API endpoints:**

- `GET /api/v1/projects/{id}/interrupts` - List pending interrupts
- `POST /api/v1/interrupts/{id}/resolve` - Submit resolution, resume production

---

### Phase 6: Production Line API

**Goal:** Aggregate production status for UI consumption.

**File:** `app/api/v1/production.py`

**Endpoints:**

| Endpoint | Purpose |
|----------|---------|
| `GET /production?project={id}` | Current state of all tracks |
| `GET /production/events?project={id}` | SSE stream (Phase 3) |
| `POST /production/start?project={id}` | [Run Full Line] |
| `POST /production/start?project={id}&doc={type}` | [Start Production] single doc |
| `GET /production/track/{execution_id}` | Station detail for one track |

**Response shape:**

```json
{
  "project_id": "...",
  "line_state": "active",
  "tracks": [
    {
      "document_type": "concierge_intake",
      "state": "stabilized",
      "stations": [...]
    },
    {
      "document_type": "project_discovery",
      "state": "auditing",
      "current_station": "aud",
      "elapsed_ms": 8234,
      "stations": [
        {"station": "bind", "state": "complete", "elapsed_ms": 150},
        {"station": "asm", "state": "complete", "elapsed_ms": 33104},
        {"station": "aud", "state": "active", "elapsed_ms": 8234}
      ]
    }
  ],
  "interrupts": [...],
  "summary": {
    "total": 7,
    "stabilized": 1,
    "active": 1,
    "blocked": 3,
    "queued": 2,
    "awaiting_operator": 0
  }
}
```

---

### Phase 7: Production Line UI

**Goal:** The primary operator surface.

**Files:**

- `app/web/templates/production/line.html` - Main template
- `app/web/templates/production/track.html` - Track component
- `app/web/templates/production/interrupt.html` - Interrupt modal
- `app/web/routes/production.py` - Routes
- `app/web/static/js/production-line.js` - SSE handling, state updates

**Components:**

1. **Line Status Bar** - "Production Line: Active | 3/7 Stabilized"
2. **Track List** - Vertical stack of document tracks
3. **Station Sequence** - Expandable branch map for active tracks
4. **Interrupt Modal** - Inline PGC/review surface
5. **Controls** - [Run Full Line], [Start Production] per doc

**Behaviors:**

- Tracks auto-expand when entering active state
- At most one remediating child auto-expands (attention focusing)
- Interrupt modal appears without page navigation
- Progress updates via SSE (no polling)
- Full-screen mode for fan-out scenarios

**URL structure:**

```
/production                    # Default, shows all projects or last active
/production?project={id}       # Specific project
/production?project={id}&focus={doc}  # With track expanded
```

---

### Phase 8: Escalation Flow

**Goal:** Operator can acknowledge halt without resolution.

**Additions to interrupt registry:**

```python
class EscalationResolution:
    acknowledged_by: str
    acknowledged_at: datetime
    notes: Optional[str]

async def escalate(self, interrupt_id: str, escalation: EscalationResolution) -> None:
    """Move document from Halted to Escalated without fixing underlying issue."""
```

**UI:** "Acknowledge & Continue" button on halt review, with optional notes field.

**Audit:** Escalations logged for compliance review.

---

## Verification Steps

### Invariant Checks

1. **No silent waiting:** Every pause has visible attribution
   - Grep for spinner/loading states; all must reference a production state

2. **No conversational terms:**
   - `grep -r "generate\|retry\|failed" app/` returns only legacy paths

3. **SSE coverage:**
   - All state transitions emit events
   - UI updates without polling

### Functional Tests

1. **[Start Production] single document:** Binding → Assembling → Auditing → Stabilized
2. **Remediation loop:** Audit reject → Remediating → Audit pass → Stabilized
3. **Circuit breaker:** Max remediation → Halted
4. **Operator interrupt:** PGC pause → Answer inline → Resume
5. **[Run Full Line]:** Dependencies respected, parallel where allowed
6. **Escalation:** Halted → Operator acknowledges → Escalated

### Visual Tests

1. Track expands on active
2. Station shows elapsed timer
3. Remediation loop renders as curve
4. Interrupt modal appears inline
5. Fan-out collapses at 15+
6. Only one remediating child expanded

---

## Out of Scope

- Mobile-optimized layout (desktop-first for control room)
- Multi-project view (single project focus for v1)
- Historical production runs (live state only for v1)
- Notifications/alerts outside the Production Line UI

---

## Dependencies

- SSE support in frontend (native EventSource)
- Existing workflow execution infrastructure
- Document type dependency graph

---

## Estimated Phases

| Phase | Dependency |
|-------|------------|
| 1: Terminology | None |
| 2: State Model | Phase 1 |
| 3: SSE Infrastructure | Phase 2 |
| 4: Orchestrator | Phase 2, 3 |
| 5: Interrupt Registry | Phase 2 |
| 6: Production API | Phase 2, 3, 4, 5 |
| 7: UI | Phase 6 |
| 8: Escalation | Phase 5, 7 |

Phases 1-2 can start immediately.
Phases 3-5 can proceed in parallel after Phase 2.
Phase 6 integrates 3-5.
Phase 7 consumes 6.
Phase 8 extends 5, 7.
