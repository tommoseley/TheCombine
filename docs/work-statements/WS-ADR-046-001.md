# WS-ADR-046-001: POW Instance Storage and Runtime Binding

**Status:** Accepted
**Created:** 2026-02-04
**Scope:** Multi-commit (migration + domain + service + API + frontend)
**ADR:** ADR-046 (Accepted)

---

## Purpose

Implement database-backed storage for POW instances -- project-scoped, mutable workflow definitions derived from reference or template POWs in `combine-config/`. This enables each project to have its own effective workflow that can diverge from the source without polluting the governed configuration namespace.

---

## Governing References

- **ADR-046**: POW Instance Storage and Runtime Binding
- **ADR-045**: System Ontology -- Primitives, Composites, and Configuration Taxonomy
- **ADR-044**: Admin Workbench with Git-Canonical Document Configuration
- **ADR-027**: Workflow Definition & Governance
- **WS-ADR-045-002**: POW Classification, Lineage, and Left Rail Grouping (Complete -- establishes `pow_class`, `derived_from`, `source_version`)
- **POL-WS-001**: Standard Work Statements

---

## Scope

### In Scope

- Database migration for `workflow_instances` and `workflow_instance_history` tables
- Domain model (`WorkflowInstance`) and repository (`WorkflowInstanceRepository`)
- Service layer for instance CRUD, snapshot creation, and drift computation
- API endpoints on `/api/v1/projects/{id}/workflow`
- Frontend: instance creation flow from project context, instance viewer/editor, drift summary
- Integration with project lifecycle (assign workflow on project create or post-creation)

### Out of Scope

- Syncing instances with updated templates ("upgrade path")
- AI-assisted drift detection or consolidation
- Cross-project workflow analytics
- Tag normalization or search infrastructure
- Production line execution from instance steps (separate work)
- Instance POWs in Admin Workbench left rail (already forward-compatible from WS-ADR-045-002; will display when data exists)

---

## Preconditions

- [x] ADR-046 accepted
- [x] ADR-045 accepted (system ontology: POW classification)
- [x] WS-ADR-045-002 complete (`pow_class`, `derived_from`, `source_version` fields operational)
- [x] `combine-config/workflows/` has at least one reference POW (`software_product_development`)
- [x] Project model operational with UUID PK, `project_id`, `status`, audit trail
- [ ] RDS PostgreSQL accessible for migration

---

## Procedure

### Phase 1: Database Migration

**Goal:** Create `workflow_instances` and `workflow_instance_history` tables.

**Migration: `workflow_instances`**

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | UUID | PK, default uuid4 | Instance identifier |
| `project_id` | UUID | FK -> projects.id, NOT NULL, UNIQUE | One active instance per project |
| `base_workflow_ref` | JSONB | NOT NULL | Source reference: `{ workflow_id, version, pow_class }` |
| `effective_workflow` | JSONB | NOT NULL | Full definition snapshot (mutable) |
| `status` | VARCHAR(50) | NOT NULL, default 'active' | `active`, `completed`, `archived` |
| `created_at` | TIMESTAMP WITH TZ | NOT NULL, server default now() | |
| `updated_at` | TIMESTAMP WITH TZ | NOT NULL, server default now(), onupdate now() | |

**Indexes:**
- `idx_workflow_instances_project_id` on `project_id` (unique)
- `idx_workflow_instances_status` on `status`

**Migration: `workflow_instance_history`**

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | UUID | PK, default uuid4 | History entry identifier |
| `instance_id` | UUID | FK -> workflow_instances.id (CASCADE), NOT NULL | Parent instance |
| `change_type` | VARCHAR(50) | NOT NULL | `created`, `step_added`, `step_removed`, `step_reordered`, `metadata_changed` |
| `change_detail` | JSONB | | Structured change description |
| `changed_at` | TIMESTAMP WITH TZ | NOT NULL, server default now() | |
| `changed_by` | VARCHAR(100) | | User or system identifier |

**Indexes:**
- `idx_workflow_instance_history_instance_id` on `instance_id`
- `idx_workflow_instance_history_changed_at` on `changed_at`

**Steps:**
1. Create migration file `alembic/versions/YYYYMMDD_001_add_workflow_instances.py`
2. Define both tables with columns, constraints, and indexes as specified
3. Run migration against dev database
4. Verify tables exist with correct schema

**Verification:**
- Migration applies cleanly (upgrade)
- Migration rolls back cleanly (downgrade)
- Tables have correct columns, types, constraints, and indexes
- Foreign key to `projects.id` enforced

---

### Phase 2: Domain Model and Repository

**Goal:** Create SQLAlchemy model and async repository for workflow instances.

**Files to create:**
- `app/api/models/workflow_instance.py` -- `WorkflowInstance` and `WorkflowInstanceHistory` models
- `app/api/repositories/workflow_instance_repository.py` -- `WorkflowInstanceRepository`

**Model: `WorkflowInstance`**
- Follows existing patterns from `app/api/models/project.py`
- Maps to `workflow_instances` table
- `base_workflow_ref` and `effective_workflow` as JSONB columns
- Relationship to `WorkflowInstanceHistory` (one-to-many, cascade delete)

**Model: `WorkflowInstanceHistory`**
- Append-only audit records
- Maps to `workflow_instance_history` table

**Repository: `WorkflowInstanceRepository`**
- `__init__(db: AsyncSession)`
- `create(project_id, base_workflow_ref, effective_workflow) -> WorkflowInstance`
- `get_by_project_id(project_id) -> Optional[WorkflowInstance]`
- `get_by_id(instance_id) -> Optional[WorkflowInstance]`
- `update_effective_workflow(instance_id, effective_workflow) -> WorkflowInstance`
- `update_status(instance_id, status) -> WorkflowInstance`
- `add_history(instance_id, change_type, change_detail, changed_by) -> WorkflowInstanceHistory`
- `get_history(instance_id, limit, offset) -> List[WorkflowInstanceHistory]`

**Steps:**
1. Create `WorkflowInstance` model following `Project` model patterns
2. Create `WorkflowInstanceHistory` model following `ProjectAudit` patterns
3. Register both models in `app/api/models/__init__.py`
4. Create `WorkflowInstanceRepository` with async CRUD methods
5. Write tier-1 tests for repository methods (in-memory / mock session)

**Verification:**
- Models import without errors
- Repository CRUD methods work against mock session
- History is append-only (no update/delete methods)
- Tier-1 tests pass

---

### Phase 3: Service Layer

**Goal:** Create `WorkflowInstanceService` with business logic for instance lifecycle and drift computation.

**File to create:**
- `app/api/services/workflow_instance_service.py`

**Class: `WorkflowInstanceService`**

**Methods:**
- `create_instance(db, project_id, workflow_id, version) -> WorkflowInstance`
  - Loads source POW definition from `PackageLoader` (using `workflow_id` + `version`)
  - Creates full snapshot as `effective_workflow`
  - Sets `base_workflow_ref` with `{ workflow_id, version, pow_class }`
  - Writes `created` history entry
  - Raises error if project already has an active instance

- `get_instance(db, project_id) -> Optional[WorkflowInstance]`
  - Returns current active instance for project

- `update_instance(db, project_id, effective_workflow, changed_by) -> WorkflowInstance`
  - Replaces `effective_workflow` with new snapshot
  - Computes change_type by diffing old vs new (step_added, step_removed, step_reordered, metadata_changed)
  - Writes history entry with change detail

- `compute_drift(db, project_id) -> DriftSummary`
  - Loads current `effective_workflow` and `base_workflow_ref`
  - Loads source POW definition from `PackageLoader`
  - Computes: steps_added, steps_removed, steps_reordered, metadata_changes
  - Returns structured summary (not stored)

- `get_history(db, project_id, limit, offset) -> List[WorkflowInstanceHistory]`
  - Returns audit trail for instance

- `complete_instance(db, project_id, changed_by) -> WorkflowInstance`
  - Sets status to `completed`

- `archive_instance(db, project_id, changed_by) -> WorkflowInstance`
  - Sets status to `archived`

**DriftSummary dataclass:**
```python
@dataclass
class DriftSummary:
    base_workflow_id: str
    base_version: str
    steps_added: List[str]      # step_ids not in source
    steps_removed: List[str]    # step_ids in source but not instance
    steps_reordered: bool       # order differs
    metadata_changed: bool      # name, description, tags differ
    is_drifted: bool            # any of the above is non-empty/True
```

**Steps:**
1. Create `WorkflowInstanceService` class
2. Implement `create_instance` with `PackageLoader` integration for loading source POW
3. Implement `update_instance` with diff-based change type detection
4. Implement `compute_drift` as a read-time comparison
5. Implement lifecycle methods (`complete_instance`, `archive_instance`)
6. Write tier-1 tests for service methods

**Verification:**
- Instance creation snapshots the full source definition
- Update detects correct change types
- Drift computation returns accurate differences
- Duplicate instance creation for same project raises error
- Tier-1 tests pass

---

### Phase 4: API Endpoints

**Goal:** Expose instance CRUD and drift via project-scoped REST endpoints.

**File to modify:**
- `app/api/v1/routers/projects.py` -- add workflow instance endpoints

**Endpoints:**

| Method | Path | Description |
|--------|------|-------------|
| `POST` | `/{project_id}/workflow` | Create instance from source POW |
| `GET` | `/{project_id}/workflow` | Get current effective workflow |
| `PUT` | `/{project_id}/workflow` | Update instance (full replacement) |
| `GET` | `/{project_id}/workflow/drift` | Compute drift from source |
| `GET` | `/{project_id}/workflow/history` | Get instance change history |
| `POST` | `/{project_id}/workflow/complete` | Mark instance as completed |

**Request models:**

```
CreateWorkflowInstanceRequest
  workflow_id: str (required)
  version: str (required)

UpdateWorkflowInstanceRequest
  effective_workflow: dict (required, full definition)
```

**Response models:**

```
WorkflowInstanceResponse
  id: UUID
  project_id: UUID
  base_workflow_ref: dict
  effective_workflow: dict
  status: str
  created_at: datetime
  updated_at: datetime

DriftResponse
  base_workflow_id: str
  base_version: str
  steps_added: List[str]
  steps_removed: List[str]
  steps_reordered: bool
  metadata_changed: bool
  is_drifted: bool

WorkflowHistoryResponse
  entries: List[HistoryEntry]
  total: int

HistoryEntry
  id: UUID
  change_type: str
  change_detail: dict
  changed_at: datetime
  changed_by: str
```

**Steps:**
1. Add request/response models to projects router
2. Implement `POST /{project_id}/workflow` -- calls `create_instance`
3. Implement `GET /{project_id}/workflow` -- returns current instance or 404
4. Implement `PUT /{project_id}/workflow` -- calls `update_instance`
5. Implement `GET /{project_id}/workflow/drift` -- calls `compute_drift`
6. Implement `GET /{project_id}/workflow/history` -- paginated history
7. Implement `POST /{project_id}/workflow/complete` -- lifecycle transition
8. All endpoints require authentication

**Verification:**
- POST creates instance and returns 201
- GET returns current instance or 404 if none
- PUT updates and returns updated instance
- Drift endpoint returns accurate comparison
- History endpoint returns paginated audit trail
- Duplicate POST returns 409 Conflict
- All endpoints enforce authentication

---

### Phase 5: Frontend -- Instance Creation and Viewer

**Goal:** Allow assigning a workflow to a project and viewing/editing the instance.

**Files to modify/create:**
- `spa/src/api/client.js` -- add workflow instance API calls
- `spa/src/components/Floor.jsx` or new `ProjectWorkflow.jsx` -- instance viewer
- Integration point in project detail view

**Instance creation flow:**
1. From project detail view, user clicks "Assign Workflow"
2. Picker shows available reference and template POWs (fetched from `/admin/workbench/orchestration-workflows`)
3. User selects a POW and confirms
4. Frontend calls `POST /api/v1/projects/{id}/workflow` with `workflow_id` and `version`
5. Instance created; view refreshes to show effective workflow

**Instance viewer:**
1. Shows current effective workflow steps (read-only initially, editable in future iteration)
2. Shows base workflow reference with version
3. Shows status badge (active, completed, archived)
4. Shows drift indicator if drifted from source (calls drift endpoint)

**Drift summary display:**
1. "In sync" badge if not drifted
2. "Drifted" badge with expandable summary if drifted
3. Lists steps added, removed, reordered

**Steps:**
1. Add API client methods for workflow instance CRUD and drift
2. Create workflow picker component for instance creation
3. Create instance viewer component showing effective workflow, status, drift
4. Integrate into project detail view (Floor component or new route)
5. Wire up drift indicator with lazy loading (fetch only when expanded)

**Verification:**
- Workflow picker shows available POWs
- Instance creation succeeds and viewer renders
- Drift indicator shows correct state
- Project with no instance shows "No workflow assigned" state

---

### Phase 6: Project Lifecycle Integration

**Goal:** Connect workflow instances to project lifecycle events.

**Integration points:**
1. **Project creation from intake:** When `POST /api/v1/projects/from-intake` creates a project, optionally assign a default workflow instance if the intake specifies one
2. **Project archive:** When a project is archived, the workflow instance status remains unchanged (preserved for audit)
3. **Project delete:** Cascade delete removes the workflow instance (FK CASCADE)
4. **Project tree view:** Include workflow assignment status in `ProjectTreeResponse`

**Steps:**
1. Extend `ProjectTreeResponse` to include `has_workflow: bool` and `workflow_status: Optional[str]`
2. Update `get_project_tree` to check for workflow instance existence
3. Optionally extend `create_project_from_intake` to accept a `workflow_id` parameter
4. Verify FK cascade behavior on project deletion

**Verification:**
- Project tree response includes workflow status
- Project deletion cascades to workflow instance
- Project archive does not affect workflow instance

---

## Prohibited Actions

- Storing instance POWs in `combine-config/` (instances are runtime data, not governed config)
- Allowing `pow_class: instance` in workspace/commit workflows (config-only classes are `reference` and `template`)
- Replaying conversation transcripts or prior assistant responses (ADR-040)
- Implementing template sync/upgrade path (explicitly out of scope)
- Modifying the `projects` table schema (use new tables only)
- Skipping the history audit trail on instance mutations

---

## Verification Checklist

- [ ] Migration creates `workflow_instances` and `workflow_instance_history` tables
- [ ] Migration rolls back cleanly
- [ ] `WorkflowInstance` and `WorkflowInstanceHistory` models load correctly
- [ ] Repository CRUD methods work (tier-1 tests)
- [ ] Service creates instance with full snapshot from source POW
- [ ] Service detects change types on update
- [ ] Service computes drift accurately
- [ ] API: POST creates instance, returns 201
- [ ] API: GET returns instance or 404
- [ ] API: PUT updates instance with history
- [ ] API: drift endpoint returns accurate comparison
- [ ] API: history endpoint returns paginated audit trail
- [ ] API: duplicate POST returns 409
- [ ] Frontend: workflow picker shows available POWs
- [ ] Frontend: instance viewer renders effective workflow
- [ ] Frontend: drift indicator works
- [ ] Project tree includes workflow status
- [ ] FK cascade on project delete removes instance
- [ ] All existing tests still pass
- [ ] Authentication enforced on all new endpoints

---

## Definition of Done

- Workflow instances storable in database with full definition snapshot
- Append-only audit trail records all instance mutations
- Drift computable at read time without stored summaries
- REST API exposes full instance lifecycle (create, read, update, drift, history, complete)
- Frontend allows assigning a workflow to a project and viewing the instance
- Project lifecycle events correctly interact with workflow instances
- No regressions in existing functionality

---

## Dependencies

| Phase | Dependency |
|-------|------------|
| Phase 1: Migration | None (can start immediately) |
| Phase 2: Domain Model | Phase 1 (needs tables to exist for model alignment) |
| Phase 3: Service Layer | Phase 2 (needs repository) |
| Phase 4: API Endpoints | Phase 3 (needs service) |
| Phase 5: Frontend | Phase 4 (needs API) |
| Phase 6: Project Lifecycle | Phases 3 + 4 (needs service + API) |

Phases are strictly sequential: 1 -> 2 -> 3 -> 4 -> 5, with Phase 6 parallelizable after Phase 4.

---

*End of WS-ADR-046-001*
