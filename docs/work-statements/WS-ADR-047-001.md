# WS-ADR-047-001: Mechanical Operations Foundation

**Status:** Complete
**Created:** 2026-02-06
**Accepted:** 2026-02-06
**Completed:** 2026-02-07
**Scope:** Multi-commit (registry + backend + frontend + workflow integration)
**ADR:** ADR-047 (Accepted)

---

## Purpose

Implement the foundation for Mechanical Operations -- non-LLM building blocks that perform deterministic data transformations within DCW workflows. This establishes the Operation Type Registry, core execution handlers (Extractor, Merger), Building Blocks tray integration, and node properties panel support for MECH nodes.

---

## Governing References

- **ADR-047**: Mechanical Operations -- Non-LLM Building Blocks
- **ADR-045**: System Ontology -- Primitives, Composites, and Configuration Taxonomy
- **ADR-041**: Prompt Template Include System
- **ADR-039**: Document Interaction Workflow Model
- **POL-WS-001**: Standard Work Statements

---

## Scope

### In Scope

- Operation Type Registry schema and seed data (`types.yaml`)
- Operation Instance storage structure in `combine-config/mechanical_ops/`
- Backend service for loading operation types and instances
- Execution handlers for Extractor and Merger operations
- `internal_type` field on workflow node definitions (LLM | MECH | UI)
- Building Blocks tray: Mechanical Ops tab with type registry integration
- Node properties panel: MECH node configuration UI
- First mechanical operation: `pgc_clarification_merge` for PGC Pass B

### Out of Scope

- Validator, Transformer, Selector operation types (Phase 3 per ADR-047)
- Full workflow execution engine integration (separate execution work)
- Operation testing/preview capability
- Facet filtering UI in Building Blocks tray (future enhancement)
- Converting existing LLM nodes to MECH (optimization phase)

---

## Preconditions

- [x] ADR-047 accepted
- [x] ADR-045 accepted (system ontology)
- [x] BuildingBlocksTray component exists (WS-ADR-044-003)
- [x] NodePropertiesPanel supports collapsible internals for gates
- [x] `combine-config/` structure operational with PackageLoader
- [x] Dev server running for frontend testing

---

## Procedure

### Phase 1: Operation Type Registry

**Goal:** Define the schema and seed data for the Operation Type Registry.

**Files to create:**
- `seed/schemas/mech-op-registry.v1.json` -- JSON Schema for types.yaml
- `seed/schemas/mechanical-operation.v1.json` -- JSON Schema for operation instances
- `combine-config/mechanical_ops/_registry/types.yaml` -- Registry seed data

**types.yaml structure:**

```yaml
$schema: https://thecombine.ai/schemas/mech-op-registry.v1.json

types:
  extractor:
    name: "Extractor"
    description: "Extracts structured fields from a document"
    icon: "scissors"
    category: "data_access"
    config_schema:
      type: object
      required: [source_type, field_paths, output_shape]
      properties:
        source_type:
          type: string
          ui_hint: "dropdown:document_types"
        field_paths:
          type: array
          items:
            type: object
            properties:
              path: { type: string }
              as: { type: string }
        output_shape:
          type: string
          ui_hint: "dropdown:schemas"
    inputs:
      - name: "source_document"
        type: "document"
    outputs:
      - name: "extracted"
        type: "object"

  merger:
    name: "Merger"
    description: "Combines multiple inputs into a single structured output"
    icon: "git-merge"
    category: "composition"
    config_schema:
      type: object
      required: [inputs, merge_strategy, output_shape]
      properties:
        inputs:
          type: array
          items:
            type: object
            properties:
              ref: { type: string }
              key: { type: string }
        merge_strategy:
          type: string
          enum: [deep_merge, shallow_merge, concatenate]
        output_shape:
          type: string
          ui_hint: "dropdown:schemas"
    inputs:
      - name: "inputs"
        type: "array"
    outputs:
      - name: "merged"
        type: "object"

categories:
  data_access:
    name: "Data Access"
    description: "Operations that read/extract from documents"
  composition:
    name: "Composition"
    description: "Operations that combine multiple inputs"
```

**Steps:**
1. Create `mech-op-registry.v1.json` schema for types.yaml validation
2. Create `mechanical-operation.v1.json` schema for operation instances
3. Create `combine-config/mechanical_ops/_registry/types.yaml` with Extractor and Merger types
4. Validate types.yaml against schema

**Verification:**
- types.yaml passes schema validation
- Both operation types have complete config_schema, inputs, outputs

---

### Phase 2: Backend -- Operation Loading Service

**Goal:** Create service for loading operation types and instances from `combine-config/`.

**Files to create/modify:**
- `app/api/services/mechanical_ops_service.py` -- New service
- `app/api/services/admin_workbench_service.py` -- Add mech ops to Building Blocks data

**Class: `MechanicalOpsService`**

```python
class MechanicalOpsService:
    def __init__(self, loader: PackageLoader):
        self.loader = loader

    def list_operation_types(self) -> List[OperationType]:
        """Load operation types from _registry/types.yaml"""

    def get_operation_type(self, type_id: str) -> Optional[OperationType]:
        """Get a specific operation type with its config schema"""

    def list_operations(self) -> List[MechanicalOperation]:
        """Load all operation instances from mechanical_ops/"""

    def get_operation(self, op_id: str, version: str) -> Optional[MechanicalOperation]:
        """Get a specific operation instance"""
```

**Dataclasses:**

```python
@dataclass
class OperationType:
    id: str
    name: str
    description: str
    icon: str
    category: str
    config_schema: dict
    inputs: List[dict]
    outputs: List[dict]

@dataclass
class MechanicalOperation:
    id: str
    version: str
    type: str  # References OperationType.id
    name: str
    description: str
    config: dict
    metadata: dict
```

**Steps:**
1. Create `MechanicalOpsService` class
2. Implement `list_operation_types` reading from `_registry/types.yaml`
3. Implement `list_operations` scanning `mechanical_ops/*/releases/*/operation.yaml`
4. Add `get_mechanical_ops()` to `AdminWorkbenchService` for Building Blocks data
5. Write tier-1 tests for service methods

**Verification:**
- Service loads types from registry
- Service loads operation instances
- Empty operations list returns cleanly (no instances yet)
- Tier-1 tests pass

---

### Phase 3: Backend -- Execution Handlers

**Goal:** Implement execution handlers for Extractor and Merger operations.

**Files to create:**
- `app/api/services/mech_handlers/__init__.py`
- `app/api/services/mech_handlers/extractor.py`
- `app/api/services/mech_handlers/merger.py`
- `app/api/services/mech_handlers/base.py`

**Base handler interface:**

```python
class MechHandler(ABC):
    @abstractmethod
    async def execute(
        self,
        config: dict,
        inputs: dict,
        context: ExecutionContext
    ) -> MechResult:
        """Execute the mechanical operation"""

@dataclass
class MechResult:
    success: bool
    output: Optional[dict]
    error: Optional[str]
    outcome: str  # For edge routing
```

**ExtractorHandler:**
- Resolves `source_document` from inputs
- Applies JSONPath expressions from `field_paths`
- Returns extracted fields matching `output_shape`
- Validates output against schema if provided

**MergerHandler:**
- Resolves multiple inputs from context
- Applies merge strategy (deep_merge, shallow_merge, concatenate)
- Returns merged object matching `output_shape`
- Validates output against schema if provided

**Steps:**
1. Create `MechHandler` base class with abstract `execute` method
2. Implement `ExtractorHandler` with JSONPath extraction
3. Implement `MergerHandler` with merge strategies
4. Create handler registry for dispatching by operation type
5. Write tier-1 tests for both handlers

**Verification:**
- ExtractorHandler extracts fields correctly using JSONPath
- MergerHandler merges inputs with all three strategies
- Handlers validate output against schema
- Handlers return appropriate error results on failure
- Tier-1 tests pass

---

### Phase 4: API Endpoints

**Goal:** Expose mechanical operations via admin API.

**Files to modify:**
- `app/api/v1/routers/admin_workbench.py` -- Add mech ops endpoints

**Endpoints:**

| Method | Path | Description |
|--------|------|-------------|
| `GET` | `/mechanical-ops/types` | List all operation types from registry |
| `GET` | `/mechanical-ops/types/{type_id}` | Get operation type with config schema |
| `GET` | `/mechanical-ops` | List all operation instances |
| `GET` | `/mechanical-ops/{op_id}` | Get operation instance |

**Response models:**

```python
class OperationTypeResponse(BaseModel):
    id: str
    name: str
    description: str
    icon: str
    category: str
    config_schema: dict
    inputs: List[dict]
    outputs: List[dict]

class MechanicalOperationResponse(BaseModel):
    id: str
    version: str
    type: str
    name: str
    description: str
    config: dict
    active_version: Optional[str]
```

**Steps:**
1. Add response models for operation types and instances
2. Implement `GET /mechanical-ops/types` endpoint
3. Implement `GET /mechanical-ops/types/{type_id}` endpoint
4. Implement `GET /mechanical-ops` endpoint
5. Implement `GET /mechanical-ops/{op_id}` endpoint
6. Wire endpoints to `MechanicalOpsService`

**Verification:**
- Types endpoint returns Extractor and Merger
- Type detail includes full config_schema
- Operations endpoint returns empty list (no instances yet)
- All endpoints require authentication

---

### Phase 5: Frontend -- Building Blocks Integration

**Goal:** Add Mechanical Ops tab to Building Blocks tray.

**Files to modify:**
- `spa/src/api/adminClient.js` -- Add mech ops API calls
- `spa/src/components/admin/BuildingBlocksTray.jsx` -- Add Mechanical Ops tab
- `spa/src/components/admin/AdminWorkbench.jsx` -- Pass mech ops data to tray

**API client additions:**

```javascript
export async function getMechanicalOpTypes() { ... }
export async function getMechanicalOps() { ... }
```

**BuildingBlocksTray changes:**
1. Add "Mechanical Ops" tab alongside Prompt Fragments, Templates, Schemas
2. Tab shows operation types from registry (grouped by category)
3. Under each type, show operation instances (if any)
4. "New Operation" button triggers creation flow (stub for now)

**UI structure:**
```
Mechanical Ops
├── Data Access
│   └── Extractor
│       └── (no instances yet)
├── Composition
│   └── Merger
│       └── (no instances yet)
└── [+ New Operation]
```

**Steps:**
1. Add API client methods for mech ops
2. Add `useMechanicalOps` hook for loading types and instances
3. Add Mechanical Ops tab to BuildingBlocksTray
4. Display types grouped by category
5. Display instances under their respective types
6. Add "New Operation" button (disabled with tooltip for now)

**Verification:**
- Mechanical Ops tab appears in Building Blocks tray
- Types load and display grouped by category
- Empty instances display gracefully
- Tab selection works correctly

---

### Phase 6: Frontend -- Node Properties Panel for MECH

**Goal:** Support MECH internal type in node properties panel.

**Files to modify:**
- `spa/src/components/admin/workflow/NodePropertiesPanel.jsx`
- `combine-config/workflows/*/releases/*/definition.json` -- Add internal_type to nodes

**Node definition changes:**

Add `internal_type` field to workflow node schema:

```json
{
  "node_id": "pgc",
  "type": "pgc",
  "internal_type": "gate",
  "internals": {
    "pass_a": { "internal_type": "LLM", ... },
    "entry": { "internal_type": "UI", ... },
    "pass_b": { "internal_type": "MECH", "op_ref": "mech:merger:pgc_clarification_merge:1.0.0", ... }
  }
}
```

**NodePropertiesPanel changes:**
1. Read `internal_type` from node or internal
2. For `internal_type: LLM` -- show Interaction Template dropdown (existing)
3. For `internal_type: MECH` -- show Operation dropdown, config preview
4. For `internal_type: UI` -- show entry prompt, input schema (stub)

**MECH configuration UI:**
- Operation dropdown populated from `/mechanical-ops`
- Config preview showing the operation's config (read-only)
- Output schema dropdown

**Steps:**
1. Update workflow node schema to include `internal_type`
2. Add internal_type detection in NodePropertiesPanel
3. Create MECH configuration section with operation dropdown
4. Display config preview when operation is selected
5. Test with manually edited workflow definition

**Verification:**
- Panel correctly detects internal_type
- MECH nodes show operation dropdown
- Config preview displays operation configuration
- LLM nodes continue to work (no regression)

---

### Phase 7: First Mechanical Operation Instance

**Goal:** Create `pgc_clarification_merge` operation for PGC Pass B.

**Files to create:**
- `combine-config/mechanical_ops/pgc_clarification_merge/releases/1.0.0/operation.yaml`

**operation.yaml:**

```yaml
$schema: https://thecombine.ai/schemas/mechanical-operation.v1.json
id: pgc_clarification_merge
version: "1.0.0"
type: merger
name: "PGC Clarification Merge"
description: "Merges clarification questions with operator answers into bound clarifications"

config:
  inputs:
    - ref: pass_a_output
      key: questions
    - ref: entry_output
      key: answers
  merge_strategy: deep_merge
  output_shape: pgc_clarifications.v1

metadata:
  created_date: "2026-02-06"
  author: "system"
  tags:
    - pgc
    - clarification
```

**Steps:**
1. Create directory structure `mechanical_ops/pgc_clarification_merge/releases/1.0.0/`
2. Create `operation.yaml` with merger configuration
3. Add to `_active/active_releases.json` mechanical_ops section
4. Verify operation loads via API

**Verification:**
- Operation appears in `/mechanical-ops` endpoint
- Operation config matches expected structure
- Building Blocks tray shows the operation under Merger type

---

## Prohibited Actions

- Creating custom code execution blocks (operations are typed and constrained)
- Modifying existing LLM execution mechanics (ADR-012)
- Implementing Validator, Transformer, Selector in this WS (Phase 3 per ADR)
- Storing operation runtime results in combine-config (runtime data, not config)
- Skipping schema validation on operation outputs
- Replaying conversation transcripts or prior assistant responses (ADR-040)

---

## Verification Checklist

- [x] types.yaml validates against mech-op-registry schema
- [x] MechanicalOpsService loads types and instances
- [x] ExtractorHandler extracts fields with JSONPath
- [x] MergerHandler merges with all strategies
- [x] API endpoints return types and instances
- [x] Building Blocks tray has Mechanical Ops tab
- [x] Types display grouped by category
- [x] NodePropertiesPanel detects internal_type
- [x] MECH nodes show operation dropdown
- [x] pgc_clarification_merge operation loads correctly
- [x] All existing tests pass
- [x] No regressions in LLM node configuration

---

## Definition of Done

- Operation Type Registry exists with Extractor and Merger types
- Backend service loads types and instances from combine-config
- Execution handlers implemented for Extractor and Merger
- API exposes operation types and instances
- Building Blocks tray displays Mechanical Ops tab
- Node properties panel supports MECH internal type
- First operation instance (pgc_clarification_merge) created and loadable
- No regressions in existing functionality

---

## Dependencies

| Phase | Dependency |
|-------|------------|
| Phase 1: Registry | None (can start immediately) |
| Phase 2: Loading Service | Phase 1 (needs registry to load) |
| Phase 3: Execution Handlers | Phase 2 (needs service for testing) |
| Phase 4: API Endpoints | Phase 2 (needs service) |
| Phase 5: Frontend Tray | Phase 4 (needs API) |
| Phase 6: Node Properties | Phase 4 (needs API for dropdown data) |
| Phase 7: First Instance | Phase 1 (needs registry structure) |

Phases 1-4 are sequential. Phases 5-6 can run in parallel after Phase 4. Phase 7 can run after Phase 1.

---

## Implementation Notes

All phases completed across multiple sessions.

### Phase 1: Operation Type Registry
- Created `combine-config/mechanical_ops/_registry/types.yaml` with 6 operation types
- Types: extractor, merger, entry, clarification_merger, invariant_pinner, exclusion_filter
- Created schema files in `combine-config/schemas/registry/`

### Phase 2: Backend Loading Service
- Created `app/api/services/mechanical_ops_service.py` with MechanicalOpsService class
- Loads types from `_registry/types.yaml` and operations from `mechanical_ops/*/releases/*/operation.yaml`
- Integrated with AdminWorkbenchService for Building Blocks data

### Phase 3: Execution Handlers
- Created `app/api/services/mech_handlers/` module with base, registry, executor
- Handler classes: ExtractorHandler, MergerHandler, EntryHandler
- Added specialized handlers in WS-ADR-047-004: ClarificationMergerHandler, InvariantPinnerHandler, ExclusionFilterHandler
- @register_handler decorator pattern for automatic registration

### Phase 4: API Endpoints
- Added endpoints to `app/api/v1/routers/admin_workbench.py`:
  - GET /mechanical-ops/types
  - GET /mechanical-ops
- Response models for OperationType and MechanicalOperation

### Phase 5: Frontend Building Blocks Integration
- Updated `spa/src/api/adminClient.js` with getMechanicalOpTypes(), getMechanicalOps()
- `spa/src/components/admin/BuildingBlocksTray.jsx` has Mechanical Ops section
- Operations grouped by type with expandable sections
- Drag-and-drop support implemented

### Phase 6: Frontend Node Properties Panel
- `spa/src/components/admin/workflow/NodePropertiesPanel.jsx` supports INTERNAL_TYPES
- MECH internal type shows operation dropdown
- UI internal type (Entry operations) also supported
- Config preview for selected operations

### Phase 7: First Mechanical Operation
- Created `pgc_clarification_merge` operation
- Added to `active_releases.json`
- Additional operations created in WS-ADR-047-003 and WS-ADR-047-004

### Files Created/Modified

| File | Change |
|------|--------|
| `combine-config/mechanical_ops/_registry/types.yaml` | Operation type registry |
| `combine-config/schemas/registry/*.json` | Registry schemas |
| `app/api/services/mechanical_ops_service.py` | Loading service |
| `app/api/services/mech_handlers/*.py` | Handler implementations |
| `app/api/v1/routers/admin_workbench.py` | API endpoints |
| `spa/src/api/adminClient.js` | Frontend API client |
| `spa/src/components/admin/BuildingBlocksTray.jsx` | Mech Ops tab |
| `spa/src/components/admin/workflow/NodePropertiesPanel.jsx` | MECH node support |
| `combine-config/mechanical_ops/*/` | Operation instances |

---

*End of WS-ADR-047-001*
