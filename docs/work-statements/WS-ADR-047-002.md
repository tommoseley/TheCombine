# WS-ADR-047-002: Entry Operations Implementation

**Status:** Draft
**Created:** 2026-02-06
**Scope:** Multi-commit (registry + backend + frontend + instances)
**ADR:** ADR-047 Addendum A (Entry Operations)

---

## Purpose

Implement Entry operations as defined in ADR-047 Addendum A. Entry operations capture structured operator input via UI components, following the same contract model as code-based mechanical ops. This enables Concierge and PGC workflows to have governed, versioned UI entry points.

---

## Governing References

- **ADR-047 Addendum A**: Entry Operations (UI Mechanical Ops)
- **ADR-047**: Mechanical Operations -- Non-LLM Building Blocks
- **WS-ADR-047-001**: Mechanical Operations Foundation (prerequisite)
- **POL-WS-001**: Standard Work Statements

---

## Scope

### In Scope

- Entry operation type definition in `types.yaml`
- Backend support for Entry operations in `MechanicalOpsService`
- React component contract and registry for Entry operations
- Two Entry operation instances: `concierge_entry`, `pgc_operator_answers`
- UI entry flow integration with workflow execution
- Node properties panel support for Entry internal type

### Out of Scope

- Full workflow execution engine integration (separate work)
- Additional Entry operation instances beyond the two specified
- Entry operation authoring UI (Entry ops are YAML-defined like other mechs)
- Concierge/PGC prompt authoring (separate WS)

---

## Preconditions

- [x] ADR-047 accepted with Addendum A
- [x] WS-ADR-047-001 complete (Operation Type Registry exists)
- [ ] MechanicalOpsService operational
- [ ] Building Blocks tray displays Mechanical Ops
- [ ] Dev server running for frontend testing

---

## Procedure

### Phase 1: Entry Type in Registry

**Goal:** Add Entry operation type to the Operation Type Registry.

**Files to modify:**
- `combine-config/mechanical_ops/_registry/types.yaml`

**Entry type definition:**

```yaml
entry:
  name: "Entry"
  description: "Captures structured input from an operator via UI"
  icon: "user-edit"
  category: "human_input"
  config_schema:
    type: object
    required: [renders, captures]
    properties:
      renders:
        type: string
        description: "Schema defining what to display to operator"
        ui_hint: "dropdown:schemas"
      captures:
        type: string
        description: "Schema defining expected operator response"
        ui_hint: "dropdown:schemas"
      entry_prompt:
        type: string
        description: "Instructions shown to operator"
      layout:
        type: string
        enum: [form, wizard, review]
        default: form
        description: "UI layout hint"
      validation_mode:
        type: string
        enum: [strict, lenient]
        default: strict
  inputs:
    - name: "context"
      type: "object"
      description: "Data to render for operator review/action"
  outputs:
    - name: "response"
      type: "object"
      description: "Structured operator input matching captures schema"
```

**Add category:**

```yaml
categories:
  # ... existing categories ...
  human_input:
    name: "Human Input"
    description: "Operations that capture structured input from operators"
```

**Steps:**
1. Add `entry` type to types.yaml under `types:`
2. Add `human_input` category under `categories:`
3. Validate types.yaml against schema

**Verification:**
- types.yaml passes schema validation
- Entry type loads via API
- Entry type appears in Building Blocks tray under "Human Input" category

---

### Phase 2: Entry Operation Instances

**Goal:** Create the two initial Entry operation instances.

**Files to create:**
- `combine-config/mechanical_ops/concierge_entry/releases/1.0.0/operation.yaml`
- `combine-config/mechanical_ops/pgc_operator_answers/releases/1.0.0/operation.yaml`

**concierge_entry/operation.yaml:**

```yaml
$schema: https://thecombine.ai/schemas/mechanical-operation.v1.json
op_id: concierge_entry
version: "1.0.0"
type: entry
name: "Concierge Entry"
description: "Operator confirms or corrects intake classification"

config:
  renders: intake_classification.v1
  captures: intake_confirmation.v1
  entry_prompt: "Review the intake classification. Confirm or correct as needed."
  layout: review

metadata:
  created_date: "2026-02-06"
  author: "system"
  tags:
    - intake
    - confirmation
```

**pgc_operator_answers/operation.yaml:**

```yaml
$schema: https://thecombine.ai/schemas/mechanical-operation.v1.json
op_id: pgc_operator_answers
version: "1.0.0"
type: entry
name: "PGC Operator Answers"
description: "Operator provides answers to generated clarification questions"

config:
  renders: clarification_question_set.v2
  captures: operator_answers.v1
  entry_prompt: "Please answer the clarification questions below."
  layout: form

metadata:
  created_date: "2026-02-06"
  author: "system"
  tags:
    - pgc
    - clarification
```

**Steps:**
1. Create directory structure for both operations
2. Create operation.yaml files
3. Add to `_active/active_releases.json`
4. Verify operations load via API

**Verification:**
- Both operations appear in `/mechanical-ops` endpoint
- Operations appear in Building Blocks tray under Entry type
- Operation details show correct config (renders, captures, layout)

---

### Phase 3: React Component Contract

**Goal:** Define and implement the React component contract for Entry operations.

**Files to create:**
- `spa/src/components/admin/entry/EntryComponentRegistry.js`
- `spa/src/components/admin/entry/GenericEntryForm.jsx`
- `spa/src/components/admin/entry/ConciergeEntryForm.jsx`
- `spa/src/components/admin/entry/PGCAnswerForm.jsx`

**Component contract:**

```typescript
interface EntryComponentProps {
  operation: MechanicalOperation;  // Full operation definition
  context: object;                  // Data matching renders schema
  onSubmit: (response: object) => void;  // Must match captures schema
  onCancel?: () => void;
}
```

**EntryComponentRegistry.js:**

```javascript
import GenericEntryForm from './GenericEntryForm';
import ConciergeEntryForm from './ConciergeEntryForm';
import PGCAnswerForm from './PGCAnswerForm';

export const entryComponents = {
  'concierge_entry': ConciergeEntryForm,
  'pgc_operator_answers': PGCAnswerForm,
  '_default': GenericEntryForm,
};

export function getEntryComponent(opId) {
  return entryComponents[opId] || entryComponents['_default'];
}
```

**GenericEntryForm.jsx:**
- Renders JSON form based on captures schema
- Uses entry_prompt as header
- Validates response against schema on submit
- Fallback for unknown Entry operations

**ConciergeEntryForm.jsx:**
- Displays intake classification summary (renders)
- Confirm/Edit toggle
- If editing, shows correction fields
- Submits confirmation or corrections (captures)

**PGCAnswerForm.jsx:**
- Renders list of clarification questions (from renders)
- Text area for each question's answer
- Validates all required questions answered
- Submits structured answers (captures)

**Steps:**
1. Create EntryComponentRegistry with component map
2. Implement GenericEntryForm as fallback
3. Implement ConciergeEntryForm for intake confirmation
4. Implement PGCAnswerForm for clarification answers
5. Add schema validation on submit

**Verification:**
- Registry correctly maps op_id to component
- GenericEntryForm renders for unknown operations
- ConciergeEntryForm shows classification and confirmation UI
- PGCAnswerForm shows questions and answer fields
- All forms validate responses before submit

---

### Phase 4: Entry Execution Flow

**Goal:** Integrate Entry operations with workflow execution.

**Files to modify:**
- `app/api/services/mech_handlers/entry.py` (new)
- `app/api/services/mech_handlers/__init__.py`
- `spa/src/components/admin/workflow/WorkflowExecutor.jsx` (or equivalent)

**Backend EntryHandler:**

```python
class EntryHandler(MechHandler):
    """
    Entry operations don't execute server-side.
    They return a 'pending_entry' status indicating UI must handle.
    """

    async def execute(
        self,
        config: dict,
        inputs: dict,
        context: ExecutionContext
    ) -> MechResult:
        return MechResult(
            success=True,
            output=None,
            error=None,
            outcome="pending_entry",
            entry_config={
                "op_id": config["op_id"],
                "renders": inputs.get("context"),
                "captures_schema": config["captures"],
            }
        )
```

**Frontend execution flow:**
1. Workflow engine encounters Entry node
2. Backend returns `pending_entry` with entry_config
3. Frontend loads appropriate Entry component from registry
4. Component renders with context data
5. Operator submits response
6. Response validated against captures schema
7. Validated response sent back to continue workflow

**Steps:**
1. Create `EntryHandler` that returns pending_entry status
2. Add entry_config to MechResult for Entry operations
3. Update frontend workflow executor to detect pending_entry
4. Integrate EntryComponentRegistry with executor
5. Handle operator submit â†’ workflow resume

**Verification:**
- Entry node execution returns pending_entry status
- Frontend correctly loads Entry component
- Operator can submit response
- Response is validated before workflow continues
- Workflow resumes with Entry output

---

### Phase 5: Node Properties Panel for Entry

**Goal:** Support Entry internal type in node properties panel.

**Files to modify:**
- `spa/src/components/admin/workflow/NodePropertiesPanel.jsx`

**Entry configuration UI:**
- Operation dropdown (filtered to Entry type only)
- renders schema display (read-only)
- captures schema display (read-only)
- entry_prompt preview
- layout selector (form/wizard/review)

**Steps:**
1. Add Entry to internal_type detection
2. Create Entry configuration section
3. Filter operation dropdown to Entry type
4. Display renders/captures schema info
5. Show entry_prompt preview

**Verification:**
- Panel correctly detects Entry internal type
- Entry nodes show Entry operation dropdown
- Configuration displays renders/captures schemas
- Entry prompt is visible

---

## Prohibited Actions

- Implementing Entry operations as bespoke React components (must use registry)
- Storing operator responses in combine-config (runtime data, not config)
- Skipping schema validation on Entry responses
- Creating Entry operations without renders/captures config
- Hardcoding Entry component selection (must use registry)

---

## Verification Checklist

- [ ] Entry type exists in types.yaml with correct schema
- [ ] human_input category added to registry
- [ ] concierge_entry operation loads via API
- [ ] pgc_operator_answers operation loads via API
- [ ] EntryComponentRegistry maps op_id to components
- [ ] GenericEntryForm renders for unknown operations
- [ ] ConciergeEntryForm displays confirmation UI
- [ ] PGCAnswerForm displays question/answer UI
- [ ] Entry nodes return pending_entry status
- [ ] Frontend loads correct Entry component
- [ ] Response validation works correctly
- [ ] Node properties panel supports Entry type
- [ ] All existing tests pass

---

## Definition of Done

- Entry operation type in registry with config schema
- Two Entry operation instances (concierge_entry, pgc_operator_answers)
- React component registry with fallback
- Specific components for Concierge and PGC
- Entry execution flow integrated with workflow
- Node properties panel supports Entry configuration
- No regressions in existing functionality

---

## Dependencies

| Phase | Dependency |
|-------|------------|
| Phase 1: Registry | WS-ADR-047-001 complete |
| Phase 2: Instances | Phase 1 |
| Phase 3: Components | Phase 2 (needs operation definitions) |
| Phase 4: Execution | Phase 3 (needs components) |
| Phase 5: Properties | Phase 1 (needs type in registry) |

Phases 1-2 are sequential. Phase 3-4 are sequential. Phase 5 can run in parallel after Phase 1.

---

*End of WS-ADR-047-002*
