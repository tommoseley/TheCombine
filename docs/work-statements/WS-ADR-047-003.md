# WS-ADR-047-003: Mechanical Operations Extraction

**Status:** Partial (Phases 1-2 complete, Phase 4 partial, Phase 3+5 deferred)
**Created:** 2026-02-06
**Scope:** Multi-commit (analysis + extraction + migration)
**ADR:** ADR-047 (Accepted)

---

## Purpose

Identify and extract existing deterministic code operations into governed Mechanical Operations. This converts "magic middle" code (embedded transformations, merges, validations) into visible, versioned, auditable artifacts that can be referenced in workflows.

---

## Governing References

- **ADR-047**: Mechanical Operations -- Non-LLM Building Blocks
- **WS-ADR-047-001**: Mechanical Operations Foundation (prerequisite)
- **ADR-045**: System Ontology
- **POL-WS-001**: Standard Work Statements

---

## Scope

### In Scope

- Audit existing handlers for extractable operations
- Create Mechanical Operations for identified patterns
- Wire existing workflows to use new Mechanical Operations
- Remove inlined deterministic code from handlers

### Out of Scope

- Creating new operations not already in code
- LLM-based operations (those stay as LLM nodes)
- Entry operations (covered by WS-ADR-047-002)
- Validator, Transformer, Selector types (registry exists, no instances needed yet)

---

## Preconditions

- [x] ADR-047 accepted
- [x] Operation Type Registry exists with Extractor, Merger types
- [ ] WS-ADR-047-001 complete (execution handlers working)
- [ ] MechanicalOpsService operational
- [ ] Dev server running for testing

---

## Procedure

### Phase 1: Codebase Audit

**Goal:** Identify all extractable deterministic operations in existing handlers.

**Audit targets:**

| Location | What to look for |
|----------|------------------|
| `app/api/services/*_handler.py` | Data transformations before/after LLM calls |
| `app/domain/services/*.py` | Field extraction, merging, validation logic |
| `app/api/v1/routers/*.py` | Request/response transformations |
| `app/llm/*.py` | Context assembly, response parsing |

**Classification criteria:**

An operation is extractable if:
1. It is deterministic (same inputs → same outputs)
2. It does not require LLM reasoning
3. It transforms, extracts, merges, or validates data
4. It could be reused in other workflows

**Deliverable:** Audit table with:
- Location (file:line)
- Current behavior description
- Proposed operation type (Extractor/Merger/Validator/Transformer/Selector)
- Proposed operation name
- Priority (high/medium/low based on reuse potential)

**Steps:**
1. Scan handler files for data transformation patterns
2. Identify JSONPath-like extractions → Extractor candidates
3. Identify multi-input combinations → Merger candidates
4. Identify schema checks before LLM calls → Validator candidates
5. Identify field renaming/restructuring → Transformer candidates
6. Identify conditional routing → Selector candidates
7. Document findings in audit table

**Verification:**
- Audit table covers all handler files
- Each candidate has clear classification
- Priority assigned based on reuse potential

---

### Phase 2: High-Priority Extractions

**Goal:** Create Mechanical Operations for high-priority candidates.

**Expected candidates (based on current system knowledge):**

| Candidate | Type | Description |
|-----------|------|-------------|
| `intake_context_extractor` | Extractor | Pulls summary/constraints from intake document |
| `discovery_summary_extractor` | Extractor | Extracts key fields for downstream nodes |
| `qa_feedback_merger` | Merger | Combines QA results with original document |
| `document_field_normalizer` | Transformer | Normalizes field names/formats |

**For each operation:**

1. Create directory: `combine-config/mechanical_ops/{op_id}/releases/1.0.0/`
2. Create `operation.yaml` with:
   - Type reference
   - Config matching type's config_schema
   - Metadata (author, tags, created_date)
3. Add to active_releases.json
4. Verify operation loads

**operation.yaml template:**

```yaml
$schema: https://thecombine.ai/schemas/mechanical-operation.v1.json
op_id: {op_id}
version: "1.0.0"
type: {extractor|merger|validator|transformer|selector}
name: "{Human Readable Name}"
description: "{What this operation does}"

config:
  # Type-specific configuration
  # See ADR-047 §4 for config schemas

metadata:
  created_date: "2026-02-06"
  author: "system"
  tags:
    - {relevant}
    - {tags}
```

**Steps:**
1. Create operation YAML for each high-priority candidate
2. Validate against mechanical-operation.v1.json schema
3. Add to active_releases.json
4. Verify each loads via API
5. Verify appears in Building Blocks tray

**Verification:**
- All high-priority operations load via API
- Operations appear in Building Blocks under correct type
- Config matches type's config_schema

---

### Phase 3: Handler Refactoring

**Goal:** Replace inlined code with Mechanical Operation references.

**For each extracted operation:**

1. Identify the handler code being replaced
2. Update handler to dispatch to MechHandler
3. Remove inlined transformation logic
4. Update workflow definition to reference the operation
5. Test that behavior is identical

**Handler refactoring pattern:**

Before:
```python
# Inlined extraction
summary = document.get("project_summary")
constraints = document.get("identified_constraints", [])
context = {"summary": summary, "constraints": constraints}
```

After:
```python
# Dispatch to mechanical operation
from app.api.services.mech_handlers import execute_operation

context = await execute_operation(
    op_ref="mech:extractor:intake_context_extractor:1.0.0",
    inputs={"source_document": document},
    context=execution_context
)
```

**Steps:**
1. For each extracted operation:
   a. Locate inlined code in handler
   b. Replace with `execute_operation` call
   c. Remove old transformation logic
   d. Update workflow definition with op_ref
2. Run existing tests to verify behavior unchanged
3. Add new tests for operation dispatch

**Verification:**
- Handler no longer contains inlined transformation
- Workflow definition references operation
- Existing tests pass (behavior unchanged)
- New tests verify operation dispatch

---

### Phase 4: Workflow Definition Updates

**Goal:** Update workflow definitions to explicitly reference Mechanical Operations.

**Files to modify:**
- `combine-config/workflows/*/releases/*/definition.json`

**Node update pattern:**

Before:
```json
{
  "node_id": "pgc",
  "type": "pgc",
  "internals": {
    "pass_b": {
      "internal_type": "LLM",
      "task_ref": "prompt:task:pgc_merge:1.0.0"
    }
  }
}
```

After:
```json
{
  "node_id": "pgc",
  "type": "pgc",
  "internals": {
    "pass_b": {
      "internal_type": "MECH",
      "op_ref": "mech:merger:pgc_clarification_merge:1.0.0"
    }
  }
}
```

**Steps:**
1. Identify all nodes that should use extracted operations
2. Update `internal_type` to `MECH`
3. Add `op_ref` with operation reference
4. Remove LLM-related fields (task_ref, role_ref) if present
5. Validate workflow definition against schema

**Verification:**
- Workflow definitions reference operations correctly
- No orphaned LLM references on MECH nodes
- Workflow editor displays MECH nodes correctly

---

### Phase 5: Cleanup and Documentation

**Goal:** Remove dead code and document the extraction.

**Cleanup tasks:**
- Remove unused transformation functions from handlers
- Remove unused imports
- Update handler docstrings to reference operations

**Documentation tasks:**
- Update ADR-047 implementation report
- Add operations to system inventory
- Document operation reuse patterns

**Steps:**
1. Remove dead transformation code
2. Run linter to find unused imports
3. Update docstrings
4. Update ADR-047 implementation status
5. Add operations to inventory doc

**Verification:**
- No dead code in handlers
- Linter passes
- Documentation reflects current state

---

## Prohibited Actions

- Extracting operations that require LLM reasoning
- Creating operations without corresponding config in handlers
- Breaking existing handler behavior during refactoring
- Skipping test verification after refactoring
- Removing code before operation is proven working

---

## Verification Checklist

- [x] Audit table completed with all candidates (27 identified)
- [x] High-priority operations created (3 new: intake_context_extractor, discovery_context_extractor, qa_feedback_merger)
- [x] Operations load via API
- [x] Operations appear in Building Blocks
- [x] Execution dispatcher created (`execute_operation`, `execute_operation_by_ref` in executor.py)
- [ ] Handlers refactored to use operations (deferred - see Implementation Notes)
- [x] Workflow definitions updated (partial - Entry ops wired in PGC node)
- [ ] All existing tests pass (pending verification)
- [ ] Dead code removed (deferred)
- [x] Documentation updated

---

## Definition of Done

- Codebase audit identifies all extractable operations
- High-priority operations exist as Mechanical Operations
- Handlers dispatch to operations instead of inlined code
- Workflow definitions reference operations explicitly
- Existing functionality unchanged
- No dead transformation code in handlers

---

## Dependencies

| Phase | Dependency |
|-------|------------|
| Phase 1: Audit | WS-ADR-047-001 complete |
| Phase 2: Extractions | Phase 1 |
| Phase 3: Refactoring | Phase 2 |
| Phase 4: Workflow Updates | Phase 3 |
| Phase 5: Cleanup | Phase 4 |

All phases are sequential.

---

## Risk Notes

| Risk | Mitigation |
|------|------------|
| Behavior change during refactoring | Run full test suite after each handler change |
| Missing edge cases in operations | Extract exact logic from handlers, don't generalize |
| Over-extraction | Only extract if reuse potential is clear |
| Incomplete audit | Use grep/search to find transformation patterns systematically |

---

## Implementation Notes

### What Was Completed

1. **Phase 1: Codebase Audit**
   - Identified 27 extractable operation candidates across handlers
   - Classified by type (Extractor, Merger, Transformer, etc.)
   - Prioritized based on reuse potential

2. **Phase 2: High-Priority Extractions**
   - Created 3 new operations: `intake_context_extractor`, `discovery_context_extractor`, `qa_feedback_merger`
   - All operations load via API and appear in Building Blocks tray
   - Handler classes exist for Extractor, Merger, Entry types

3. **Execution Dispatcher** (bonus)
   - Created `app/api/services/mech_handlers/executor.py`
   - `execute_operation()` - dispatch by operation definition
   - `execute_operation_by_ref()` - dispatch by op_ref string
   - Connects YAML definitions → handler registry → execution

4. **Phase 4: Workflow Definition Updates** (partial)
   - Updated `project_discovery` workflow PGC node `operator_entry` internal to reference `mech:entry:pgc_operator_answers:1.0.0`

### What's Deferred (Phase 3)

Handler refactoring was found to be more complex than initially scoped:

1. **Existing code uses specialized functions** - The `clarification_merger` module does more than simple deep-merge (normalization, matching, extraction)
2. **No simple inline patterns** - The code doesn't have simple `doc.get("field")` extractions that match the Extractor pattern
3. **Tightly integrated with workflow state** - Transformations are woven into `plan_executor.py` state management

**Recommendation**: Handler refactoring should be a separate work statement with dedicated scope for:
- Abstracting `clarification_merger` logic into a configurable operation
- Creating specialized handler types for complex transformations
- Proper test coverage before/after refactoring

### Files Created/Modified

| File | Change |
|------|--------|
| `combine-config/mechanical_ops/intake_context_extractor/` | New Extractor operation |
| `combine-config/mechanical_ops/discovery_context_extractor/` | New Extractor operation |
| `combine-config/mechanical_ops/qa_feedback_merger/` | New Merger operation |
| `app/api/services/mech_handlers/executor.py` | New execution dispatcher |
| `app/api/services/mech_handlers/__init__.py` | Export executor functions |
| `combine-config/workflows/project_discovery/.../definition.json` | PGC operator_entry wired to Entry op |
| `combine-config/_active/active_releases.json` | Added new operations |

---

*End of WS-ADR-047-003*
