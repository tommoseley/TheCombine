# WS-ADR-047-004: Mechanical Operations Handler Refactoring

**Status:** Draft
**Created:** 2026-02-07
**Scope:** Multi-commit (design + implementation + migration)
**ADR:** ADR-047 (Accepted)
**Predecessor:** WS-ADR-047-003 (Phase 3 deferred)

---

## Purpose

Refactor existing handler code to dispatch through the Mechanical Operations framework. This completes the extraction work started in WS-ADR-047-003 by creating specialized handler types for complex transformations and migrating inline code to use `execute_operation()`.

---

## Governing References

- **ADR-047**: Mechanical Operations -- Non-LLM Building Blocks
- **WS-ADR-047-001**: Mechanical Operations Foundation
- **WS-ADR-047-003**: Mechanical Operations Extraction (Phases 1-2 complete)
- **POL-WS-001**: Standard Work Statements

---

## Background

WS-ADR-047-003 Phase 3 was deferred because the existing code patterns don't match the simple extraction/merge model:

1. **Specialized functions** - Logic lives in `clarification_merger.py`, not inline
2. **Complex processing** - Answer normalization, question matching, invariant derivation
3. **State coupling** - Transformations access `state.context_state` directly
4. **No 1:1 mapping** - Created operations don't map to actual code paths

This work statement addresses these gaps with targeted refactoring.

---

## Scope

### In Scope

- Create specialized handler types for complex transformations
- Abstract `clarification_merger` logic into configurable operation
- Create `invariant_pinner` operation for constraint pinning
- Refactor `plan_executor.py` to use `execute_operation()` dispatch
- Maintain backward compatibility during migration

### Out of Scope

- New operation types beyond what's needed for existing code
- Changes to workflow definitions (covered by WS-ADR-047-003 Phase 4)
- UI changes to workflow editor
- Performance optimization

---

## Preconditions

- [x] ADR-047 accepted
- [x] WS-ADR-047-001 complete (handler framework exists)
- [x] WS-ADR-047-003 Phases 1-2 complete (executor exists)
- [ ] Test coverage for `clarification_merger.py` functions
- [ ] Test coverage for `plan_executor.py` transformation methods

---

## Procedure

### Phase 1: Test Coverage Baseline

**Goal:** Establish test coverage for code being refactored.

**Files requiring tests:**

| File | Functions | Current Coverage |
|------|-----------|------------------|
| `clarification_merger.py` | `merge_clarifications()`, `extract_invariants()` | TBD |
| `plan_executor.py` | `_pin_invariants_to_known_constraints()`, `_filter_excluded_topics()` | TBD |

**Steps:**
1. Audit existing test coverage for target functions
2. Write unit tests for `merge_clarifications()` with edge cases:
   - Empty questions/answers
   - Mismatched question IDs
   - Priority-based binding
   - Exclusion-based binding
3. Write unit tests for `extract_invariants()`:
   - No binding constraints
   - Mixed binding/non-binding
   - Canonical tag extraction
4. Write unit tests for `_pin_invariants_to_known_constraints()`:
   - No invariants
   - Duplicate detection
   - Constraint merging
5. Write unit tests for `_filter_excluded_topics()`:
   - No exclusions
   - Recommendation filtering
   - Decision point filtering

**Verification:**
- All target functions have >80% test coverage
- Tests document expected behavior (serve as specification)

---

### Phase 2: Specialized Handler Types

**Goal:** Create handler types for complex transformations.

**New types to add to `types.yaml`:**

```yaml
clarification_merger:
  name: "Clarification Merger"
  description: "Merges PGC questions with operator answers, derives binding constraints"
  icon: "message-square-plus"
  category: "composition"
  config_schema:
    type: object
    properties:
      extract_invariants:
        type: boolean
        default: true
        description: "Also extract binding invariants"
      normalize_answers:
        type: boolean
        default: true
        description: "Normalize answer text to canonical form"

invariant_pinner:
  name: "Invariant Pinner"
  description: "Pins binding invariants into document known_constraints"
  icon: "pin"
  category: "data_transform"
  config_schema:
    type: object
    properties:
      deduplicate:
        type: boolean
        default: true
        description: "Remove LLM constraints that duplicate pinned ones"
      source_field:
        type: string
        default: "pgc_invariants"
        description: "Context state field containing invariants"

exclusion_filter:
  name: "Exclusion Filter"
  description: "Filters document sections mentioning excluded topics"
  icon: "filter-x"
  category: "data_transform"
  config_schema:
    type: object
    properties:
      filter_recommendations:
        type: boolean
        default: true
      filter_decision_points:
        type: boolean
        default: true
      tag_match_threshold:
        type: integer
        default: 2
        description: "Minimum tag matches for duplicate detection"
```

**Steps:**
1. Add new types to `combine-config/mechanical_ops/_registry/types.yaml`
2. Create handler classes in `app/api/services/mech_handlers/`:
   - `clarification_merger.py` - ClarificationMergerHandler
   - `invariant_pinner.py` - InvariantPinnerHandler
   - `exclusion_filter.py` - ExclusionFilterHandler
3. Register handlers in `registry.py`
4. Update `__init__.py` exports

**Handler implementation pattern:**

```python
class ClarificationMergerHandler(MechHandler):
    """Handler for clarification_merger operations."""

    operation_type = "clarification_merger"

    async def execute(self, config: Dict[str, Any], context: ExecutionContext) -> MechResult:
        questions = context.get_input("questions")
        answers = context.get_input("answers")

        if not questions or not answers:
            return MechResult.fail(
                error="Missing required inputs: questions, answers",
                error_code="missing_input"
            )

        # Import existing logic (initially) - will inline later
        from app.domain.workflow.clarification_merger import (
            merge_clarifications,
            extract_invariants,
        )

        clarifications = merge_clarifications(questions, answers)

        output = {"clarifications": clarifications}

        if config.get("extract_invariants", True):
            invariants = extract_invariants(clarifications)
            output["invariants"] = invariants

        return MechResult.success(output=output)
```

**Verification:**
- New types appear in API `/mechanical-ops/types`
- Handler unit tests pass
- Handlers can be instantiated and executed

---

### Phase 3: Create Operation Instances

**Goal:** Create YAML operation definitions for each use case.

**Operations to create:**

| Operation ID | Type | Description |
|--------------|------|-------------|
| `pgc_clarification_processor` | clarification_merger | Replaces `merge_clarifications()` call in plan_executor |
| `discovery_invariant_pinner` | invariant_pinner | Replaces `_pin_invariants_to_known_constraints()` |
| `discovery_exclusion_filter` | exclusion_filter | Replaces `_filter_excluded_topics()` |

**Steps:**
1. Create operation directories and YAML files
2. Add to `active_releases.json`
3. Verify operations load via API
4. Verify operations appear in Building Blocks

**Verification:**
- All operations load without errors
- Operations appear in correct categories in Building Blocks

---

### Phase 4: Refactor plan_executor.py

**Goal:** Replace inline code with `execute_operation()` calls.

**Refactoring targets:**

**4a. PGC Answer Processing (lines 322-331)**

Before:
```python
from app.domain.workflow.clarification_merger import merge_clarifications, extract_invariants
clarifications = merge_clarifications(questions, user_input)
invariants = extract_invariants(clarifications)
state.update_context_state({
    "pgc_answers": user_input,
    "pgc_clarifications": clarifications,
    "pgc_invariants": invariants,
})
```

After:
```python
from app.api.services.mech_handlers import execute_operation_by_ref

result = await execute_operation_by_ref(
    op_ref="mech:clarification_merger:pgc_clarification_processor:1.0.0",
    inputs={"questions": questions, "answers": user_input},
    ops_service=self._ops_service,
    workflow_id=state.workflow_id,
    node_id=current_node.node_id,
)

if not result.success:
    raise PlanExecutorError(f"Clarification merge failed: {result.error}")

state.update_context_state({
    "pgc_answers": user_input,
    "pgc_clarifications": result.output["clarifications"],
    "pgc_invariants": result.output.get("invariants", []),
})
```

**4b. Invariant Pinning (lines 797-800)**

Before:
```python
pinned_document = self._pin_invariants_to_known_constraints(
    result.produced_document, state
)
```

After:
```python
pin_result = await execute_operation_by_ref(
    op_ref="mech:invariant_pinner:discovery_invariant_pinner:1.0.0",
    inputs={
        "document": result.produced_document,
        "invariants": state.context_state.get("pgc_invariants", []),
    },
    ops_service=self._ops_service,
)
pinned_document = pin_result.output if pin_result.success else result.produced_document
```

**4c. Exclusion Filtering (lines 803)**

Before:
```python
filtered_document = self._filter_excluded_topics(pinned_document, state)
```

After:
```python
filter_result = await execute_operation_by_ref(
    op_ref="mech:exclusion_filter:discovery_exclusion_filter:1.0.0",
    inputs={
        "document": pinned_document,
        "invariants": state.context_state.get("pgc_invariants", []),
    },
    ops_service=self._ops_service,
)
filtered_document = filter_result.output if filter_result.success else pinned_document
```

**Steps:**
1. Inject `MechanicalOpsService` into `PlanExecutor.__init__()`
2. Refactor PGC answer processing
3. Run tests - verify behavior unchanged
4. Refactor invariant pinning
5. Run tests - verify behavior unchanged
6. Refactor exclusion filtering
7. Run tests - verify behavior unchanged

**Verification:**
- All existing tests pass
- Workflow execution produces identical results
- Operations are logged in execution history

---

### Phase 5: Cleanup

**Goal:** Remove dead code and update documentation.

**Cleanup tasks:**
1. Mark private methods as deprecated (keep for one release):
   - `_pin_invariants_to_known_constraints()`
   - `_filter_excluded_topics()`
   - Related helper methods
2. Update docstrings to reference operations
3. Update ADR-047 implementation report
4. Close WS-ADR-047-003 as superseded

**Steps:**
1. Add deprecation warnings to old methods
2. Update plan_executor.py docstrings
3. Update ADR-047 with implementation status
4. Update WS-ADR-047-003 status to "Superseded by WS-ADR-047-004"

**Verification:**
- Deprecation warnings appear in logs when old methods called
- Documentation reflects current state

---

## Prohibited Actions

- Removing old methods before operations are proven working
- Changing behavior during refactoring (must be identical)
- Skipping test verification between refactoring steps
- Modifying `clarification_merger.py` logic (just wrap it)

---

## Verification Checklist

- [ ] Test coverage established for target functions
- [ ] New handler types registered and working
- [ ] Operation instances created and loading
- [ ] PGC answer processing refactored
- [ ] Invariant pinning refactored
- [ ] Exclusion filtering refactored
- [ ] All existing tests pass
- [ ] Workflow execution identical before/after
- [ ] Dead code marked deprecated
- [ ] Documentation updated

---

## Definition of Done

- All transformation logic dispatches through `execute_operation()`
- Existing behavior unchanged (verified by tests)
- Operations visible in Building Blocks tray
- Old methods deprecated but preserved for backward compatibility
- ADR-047 implementation report updated

---

## Dependencies

| Phase | Dependency |
|-------|------------|
| Phase 1: Tests | None |
| Phase 2: Handler Types | Phase 1 |
| Phase 3: Operations | Phase 2 |
| Phase 4: Refactoring | Phase 3 |
| Phase 5: Cleanup | Phase 4 |

All phases are sequential.

---

## Risk Notes

| Risk | Mitigation |
|------|------------|
| Behavior change during refactoring | Run full test suite after each change |
| Missing edge cases | Phase 1 establishes test coverage first |
| Performance regression | Benchmark before/after (add if needed) |
| Circular imports | Handler imports existing module, doesn't duplicate logic |

---

## Estimated Effort

| Phase | Effort |
|-------|--------|
| Phase 1: Test Coverage | Medium - depends on current coverage |
| Phase 2: Handler Types | Small - mostly boilerplate |
| Phase 3: Operations | Small - YAML definitions |
| Phase 4: Refactoring | Medium - careful incremental changes |
| Phase 5: Cleanup | Small - documentation updates |

---

*End of WS-ADR-047-004*
