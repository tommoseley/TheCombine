# WS-CRAP-001: Testability Refactoring -- Workflow Engine Batch 1 (PlanExecutor + QANodeExecutor Core)

## Status: Draft (generated by crap-refactor skill)

## Parent Work Package
WP-CRAP-001: Testability Refactoring

## Target Functions

| # | CRAP | CC | Coverage | File | Function | Proposed Action |
|---|------|-----|----------|------|----------|-----------------|
| 1 | 2190.4 | 47 | 1.0% | app/domain/workflow/plan_executor.py:824 | PlanExecutor._handle_result() | Class-level decomposition: extract result-type dispatch table + per-type handler methods |
| 2 | 1580.7 | 40 | 1.2% | app/domain/workflow/nodes/qa.py:86 | QANodeExecutor.execute() | Class-level decomposition: extract QA mode dispatch; separate semantic/code/schema execution paths |
| 3 | 720.7 | 27 | 1.6% | app/domain/workflow/plan_executor.py:1518 | PlanExecutor._filter_excluded_topics() | Extract filter predicate logic into pure function |
| 4 | 714.0 | 27 | 2.0% | app/domain/workflow/nodes/qa.py:844 | QANodeExecutor._parse_qa_response() | Extract JSON parsing, field mapping, and fallback logic into pure functions |
| 5 | 528.0 | 23 | 1.5% | app/domain/workflow/plan_executor.py:287 | PlanExecutor.execute_step() | Extract node-type dispatch table and separate pre/post lifecycle hooks |

## Refactoring Strategy

This batch targets the two highest-complexity methods in the entire codebase. These are NOT
simple function extractions -- they require structural decomposition at the class level.

### _handle_result (CC=47)

This is the single highest-complexity method in the Workflow Engine. CC=47 indicates a massive
if/elif chain dispatching on result types. The refactoring pattern is:

1. Identify every result type branch (there should be ~15-20 distinct result types)
2. Extract each branch into a dedicated handler method: `_handle_success_result()`,
   `_handle_error_result()`, `_handle_retry_result()`, etc.
3. Build a dispatch table mapping result type -> handler method
4. Reduce `_handle_result()` to: lookup in dispatch table, call handler, return
5. Each extracted handler is independently testable

Expected CC after: _handle_result ~3-5 (dispatch only), each handler ~3-8

### QANodeExecutor.execute (CC=40)

Three distinct QA modes (semantic, code-based, schema) are interleaved with setup/teardown
logic. The refactoring pattern is:

1. Extract mode detection into a pure function
2. Extract each mode's execution into a dedicated method
3. Factor common setup/teardown into before/after hooks
4. Reduce `execute()` to: detect mode -> setup -> dispatch to mode handler -> teardown

Expected CC after: execute ~5-8, each mode handler ~8-12

### _filter_excluded_topics (CC=27)

Complex predicate logic that is purely functional. Extract the predicate into a standalone
pure function that takes topic data and exclusion criteria, returns bool.

### _parse_qa_response (CC=27)

JSON parsing with many conditional field mappings and fallbacks. Extract:
1. JSON extraction logic (pure)
2. Field mapping/normalization (pure)
3. Fallback resolution (pure)

### execute_step (CC=23)

Mixes node-type routing with lifecycle management. Extract:
1. Node-type dispatch table (dict mapping type -> executor)
2. Pre-step hooks into a separate method
3. Post-step hooks into a separate method

## Acceptance Criteria
1. All target functions have CRAP score < 30 after refactoring
2. Test coverage for target functions is >= 70%
3. No behavioral changes (existing tests still pass)
4. Tier-0 green
5. New tests are Tier-1 (in-memory, no DB, no I/O)

## Prohibited Actions
- Do NOT change function signatures that are part of the public API
- Do NOT merge or delete existing test files
- Do NOT refactor functions not listed in Target Functions
- Do NOT add database dependencies to extracted functions

## Allowed Paths
- app/domain/workflow/
- tests/tier1/
