# WS-CRAP-007: Testability Refactoring -- Workflow Engine Batch 2 (Supporting Classes)

## Status: Draft (generated by crap-refactor skill)

## Parent Work Package
WP-CRAP-001: Testability Refactoring

## Target Functions

| # | CRAP | CC | Coverage | File | Function | Proposed Action |
|---|------|-----|----------|------|----------|-----------------|
| 1 | 312.5 | 19 | 6.7% | app/domain/workflow/pg_state_persistence.py:185 | PgStatePersistence._row_to_state() | Extract field mapping into pure dict-to-model converter |
| 2 | 256.3 | 16 | 2.1% | app/domain/workflow/plan_executor.py:1399 | PlanExecutor._pin_invariants_to_known_constraints() | Extract constraint matching and merge logic into pure functions |
| 3 | 228.6 | 15 | 1.7% | app/domain/workflow/plan_executor.py:1813 | PlanExecutor._persist_produced_documents() | Split document assembly (pure) from persistence calls (I/O) |
| 4 | 193.2 | 14 | 2.9% | app/domain/workflow/nodes/qa.py:437 | QANodeExecutor._run_semantic_qa() | Extract prompt construction and response interpretation into pure functions |
| 5 | 171.0 | 13 | 2.2% | app/domain/workflow/nodes/gate.py:377 | GateNodeExecutor._execute_pgc_gate() | Extract PGC context assembly and result interpretation into pure functions |

## Refactoring Strategy

This batch targets the next tier of workflow engine complexity. Unlike WS-CRAP-001, these are
standard Extract Pure Logic refactorings -- the functions mix orchestration with business logic
that can be cleanly separated.

### _row_to_state (CC=19)

Dict-to-model mapping with many conditional field extractions and type coercions. Pattern:

1. Extract field-level converters: `_parse_timestamp()`, `_parse_metadata()`, etc.
2. Extract the full dict-to-model mapping into a standalone pure function
3. Reduce `_row_to_state()` to: call pure mapper, handle DB-specific edge cases

### _pin_invariants_to_known_constraints (CC=16)

Constraint matching is pure logic buried in an orchestration method. Pattern:

1. Extract constraint matching predicate (does invariant X match constraint Y?)
2. Extract merge logic (how to combine matched pairs)
3. Keep orchestration shell that iterates and delegates

### _persist_produced_documents (CC=15)

Document assembly is distinct from persistence. Pattern:

1. Extract `_assemble_document_content()` -- pure function that builds the document dict
2. Keep `_persist_produced_documents()` as thin I/O wrapper that calls assemble then saves

### _run_semantic_qa (CC=14)

Prompt construction and response parsing are independently testable. Pattern:

1. Extract `_build_semantic_qa_prompt()` -- pure function
2. Extract `_interpret_semantic_qa_response()` -- pure function
3. Keep `_run_semantic_qa()` as orchestrator: build prompt -> call LLM -> interpret response

### _execute_pgc_gate (CC=13)

PGC context assembly and result interpretation are pure functions. Pattern:

1. Extract `_assemble_pgc_context()` -- pure function
2. Extract `_interpret_pgc_result()` -- pure function
3. Keep `_execute_pgc_gate()` as orchestrator

## Dependencies

- WS-CRAP-001 should be completed first. Functions 2 and 3 are in PlanExecutor, which
  WS-CRAP-001 restructures more heavily. Completing WS-CRAP-001 first avoids merge conflicts
  and ensures the extraction targets are stable.

## Acceptance Criteria
1. All target functions have CRAP score < 30 after refactoring
2. Test coverage for target functions is >= 70%
3. No behavioral changes (existing tests still pass)
4. Tier-0 green
5. New tests are Tier-1 (in-memory, no DB, no I/O)

## Prohibited Actions
- Do NOT change function signatures that are part of the public API
- Do NOT merge or delete existing test files
- Do NOT refactor functions not listed in Target Functions
- Do NOT add database dependencies to extracted functions

## Allowed Paths
- app/domain/workflow/
- tests/tier1/
