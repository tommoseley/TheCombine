{
  "type": "canonical_architecture",
  "version": 1.1,
  "metadata": {
    "product_name": "Workbench AI",
    "revision": "1.1",
    "revision_date": "2024-11-29",
    "revision_notes": "Structural correction: Fixed repository layout, import model, and execution model to establish single source of truth for project structure.",
    "status": "approved"
  },
  "sections": {
    "summary": {
      "blocks": [
        {
          "id": "summary-1",
          "type": "paragraph",
          "content": "The canonical architecture is a Python-based MVP optimized for rapid delivery (3 months) with FastAPI backend, minimal HTMX UI, and canonical document storage as the authoritative source of truth. The architecture enforces schema validation at every stage via Pydantic models, ensuring all artifacts conform to standardized structures before persistence."
        },
        {
          "id": "summary-2",
          "type": "paragraph",
          "content": "The system uses FastAPI for async API endpoints, Jinja2 for server-side HTML rendering, HTMX for dynamic interactions without JavaScript framework overhead, and SQLite for zero-configuration data persistence with a clear migration path to PostgreSQL. All AI agent outputs are validated against Pydantic schemas before storage in the canonical_documents table, which serves as the single source of truth for all downstream operations."
        },
        {
          "id": "summary-3",
          "type": "paragraph",
          "content": "Key architectural decisions prioritize operational simplicity: single Docker container deployment, synchronous orchestration via Python asyncio for concurrent agent execution, local filesystem for ephemeral exports, and magic-link authentication (no third-party providers in Phase 1). The architecture avoids SPA frameworks, microservices, and job queues in favor of Python-native solutions that enable faster iteration and lower operational complexity."
        }
      ]
    },
    "repository_structure": {
      "blocks": [
        {
          "id": "repo-structure-overview",
          "type": "paragraph",
          "content": "The Experience App follows a canonical Python package structure with all application code under the app/ package. This structure is fixed and must not be altered without explicit architectural approval. All development, testing, and orchestration tooling must conform to this layout."
        },
        {
          "id": "repo-structure-diagram",
          "type": "code",
          "language": "text",
          "content": "experience/\n├── app/                      # Main application package\n│   ├── __init__.py           # Package marker\n│   ├── main.py               # FastAPI application (canonical entrypoint)\n│   ├── routers/              # Feature-based API routers\n│   │   ├── __init__.py\n│   │   ├── repo_view.py\n│   │   ├── workspace.py\n│   │   └── ...\n│   ├── schemas/              # Pydantic request/response models\n│   │   ├── __init__.py\n│   │   ├── repo_view.py\n│   │   └── ...\n│   ├── services/             # Business logic layer\n│   │   ├── __init__.py\n│   │   ├── repo_reader.py\n│   │   ├── orchestrator_core.py\n│   │   └── ...\n│   └── models/               # SQLAlchemy ORM models\n│       ├── __init__.py\n│       ├── workspace.py\n│       └── ...\n├── tests/                    # Test suite (pytest)\n│   ├── __init__.py\n│   ├── test_repo_view.py\n│   └── ...\n├── docs/                     # Project documentation\n├── templates/                # Jinja2 HTML templates\n├── static/                   # Static assets (CSS, JS, images)\n└── pyproject.toml            # Python project configuration"
        },
        {
          "id": "repo-structure-rationale",
          "type": "paragraph",
          "content": "Rationale: This structure treats experience/ as the project root and app/ as a proper Python package. All modules are importable using absolute imports (from app.routers import ...), avoiding relative import complexity and enabling consistent module resolution across development, testing, and production. The FastAPI application lives at app/main.py (not experience/main.py) to maintain clean package boundaries and enable proper namespace isolation."
        }
      ]
    },
    "import_model": {
      "blocks": [
        {
          "id": "import-model-rules",
          "type": "paragraph",
          "content": "All modules within the Experience App MUST use absolute imports following the canonical pattern: from app.<submodule> import <object>. This import model is enforced across all application code, tests, and orchestration scripts."
        },
        {
          "id": "import-model-examples",
          "type": "code",
          "language": "python",
          "content": "# ✅ CORRECT: Absolute imports from app package\nfrom app.routers import repo_view\nfrom app.schemas.repo_view import RepoFilesResponse\nfrom app.services.repo_reader import repo_reader\nfrom app.models.workspace import Workspace\nfrom app.main import app\n\n# ❌ INCORRECT: Do not use these patterns\nfrom experience.app.routers import repo_view  # Wrong: experience/ is project root, not a package\nfrom main import app                          # Wrong: main.py is not in project root\nfrom .main import app                         # Wrong: relative imports from app/__init__.py only"
        },
        {
          "id": "import-model-entrypoint",
          "type": "paragraph",
          "content": "The canonical FastAPI application entrypoint is: from app.main import app. This import path is used by uvicorn, test suites, and any orchestration tooling that needs to reference the FastAPI instance."
        },
        {
          "id": "import-model-rationale",
          "type": "paragraph",
          "content": "Rationale: Absolute imports from the app package eliminate ambiguity about module resolution, prevent circular import issues, and enable consistent behavior across all execution contexts (uvicorn, pytest, scripts). By treating app/ as the canonical package (not experience.app), we avoid nested package complexity and maintain a flat, predictable import hierarchy."
        }
      ]
    },
    "execution_model": {
      "blocks": [
        {
          "id": "execution-model-run",
          "type": "paragraph",
          "content": "The Experience App is executed by changing into the experience/ directory and running uvicorn with the canonical app path. This execution model is fixed and must be used for all development, testing, and deployment scenarios."
        },
        {
          "id": "execution-model-commands",
          "type": "code",
          "language": "bash",
          "content": "# Canonical development server startup\ncd experience\nuvicorn app.main:app --reload\n\n# Production startup (without auto-reload)\ncd experience\nuvicorn app.main:app --host 0.0.0.0 --port 8000\n\n# Run tests\ncd experience\npytest tests/\n\n# Run tests with coverage\ncd experience\npytest tests/ --cov=app --cov-report=term-missing"
        },
        {
          "id": "execution-model-working-directory",
          "type": "paragraph",
          "content": "Working directory: All commands must be executed from the experience/ directory. This ensures Python can resolve the app package correctly and that relative paths (templates/, static/, workbench.db) are resolved consistently. Docker containers and CI/CD pipelines must set WORKDIR to /app/experience or equivalent."
        },
        {
          "id": "execution-model-rationale",
          "type": "paragraph",
          "content": "Rationale: By requiring cd experience before execution, we establish experience/ as the canonical working directory. This eliminates path resolution ambiguity: Python adds the current directory to sys.path, making app/ importable as a top-level package. All file system operations (SQLite database, templates, static assets) use paths relative to experience/, preventing path confusion across development and production environments."
        }
      ]
    },
    "diagram": {
      "blocks": [
        {
          "id": "diagram-1",
          "type": "code",
          "language": "text",
          "content": "┌──────────────────────────────────────────────────────┐\n│              User Browser                            │\n│  Jinja2 HTML + HTMX + EventSource (SSE)              │\n└────────────────────┬─────────────────────────────────┘\n                     │ HTTPS\n                     │\n┌────────────────────▼─────────────────────────────────┐\n│            FastAPI Application                       │\n│            (app/main.py)                             │\n│                                                      │\n│  ┌──────────────────────────────────────────────┐   │\n│  │         API Layer (FastAPI)                  │   │\n│  │  - REST endpoints (/workspaces, /approve)    │   │\n│  │  - SSE streaming (/stream)                   │   │\n│  │  - Pydantic validation                       │   │\n│  │  Location: app/routers/                      │   │\n│  └────────────────┬─────────────────────────────┘   │\n│                   │                                  │\n│  ┌────────────────▼─────────────────────────────┐   │\n│  │      Orchestration Core (Python)             │   │\n│  │  - State machine (PM → Arch → BA)            │   │\n│  │  - Agent dispatcher (asyncio.gather)         │   │\n│  │  - Approval gate manager                     │   │\n│  │  Location: app/services/orchestrator_core.py │   │\n│  └────────────────┬─────────────────────────────┘   │\n│                   │                                  │\n│  ┌────────────────▼─────────────────────────────┐   │\n│  │       Agent Service (Anthropic SDK)          │   │\n│  │  - anthropic.AsyncAnthropic                  │   │\n│  │  - Prompt management                         │   │\n│  │  - Streaming responses                       │   │\n│  │  Location: app/services/*_agent_service.py   │   │\n│  └────────────────┬─────────────────────────────┘   │\n│                   │                                  │\n│  ┌────────────────▼─────────────────────────────┐   │\n│  │    Schema Validation (Pydantic)              │   │\n│  │  - CanonicalArchitectureV1 model             │   │\n│  │  - Block type enforcement                    │   │\n│  │  - ID uniqueness validation                  │   │\n│  │  Location: app/schemas/                      │   │\n│  └────────────────┬─────────────────────────────┘   │\n│                   │                                  │\n│  ┌────────────────▼─────────────────────────────┐   │\n│  │  Canonical Document Store (SQLite/SQLAlchemy)│   │\n│  │  - workspaces                                │   │\n│  │  - canonical_documents (JSON)                │   │\n│  │  - pipeline_state (JSON)                     │   │\n│  │  - agent_logs                                │   │\n│  │  Location: experience/workbench.db           │   │\n│  └──────────────────────────────────────────────┘   │\n│                                                      │\n│  Anthropic API (HTTPS) ─────────────────────────────→│\n└──────────────────────────────────────────────────────┘\n           Single Docker Container\n       (Working Directory: /app/experience)"
        }
      ]
    },
    "components": {
      "blocks": [
        {
          "id": "component-presentation",
          "type": "component",
          "data": {
            "name": "Presentation Layer",
            "technology": "Jinja2 Templates + HTMX + Tailwind CSS (CDN) + EventSource API",
            "location": "templates/",
            "responsibilities": [
              "Server-side HTML rendering via Jinja2 templates",
              "Dynamic interactions via HTMX (hx-get, hx-post, hx-swap)",
              "Real-time agent streaming via EventSource (SSE)",
              "Styling via Tailwind CSS (CDN, no build step)",
              "Form submissions and approval gate UI",
              "Export download links"
            ],
            "rationale": "Server-side rendering eliminates build pipeline complexity. HTMX provides SPA-like interactions with minimal JavaScript payload. EventSource API handles SSE streaming natively. Tailwind CSS via CDN avoids compilation step. This approach delivers interactive UI functionality with significantly reduced frontend complexity compared to SPA frameworks."
          }
        },
        {
          "id": "component-api",
          "type": "component",
          "data": {
            "name": "API Layer",
            "technology": "FastAPI + Pydantic + Uvicorn",
            "location": "app/routers/",
            "responsibilities": [
              "RESTful endpoints: POST /workspaces, GET /workspaces/{id}, POST /workspaces/{id}/submit",
              "Approval endpoints: POST /workspaces/{id}/approve?stage=epic|architecture|backlog",
              "SSE streaming endpoint: GET /workspaces/{id}/stream (yields agent outputs via StreamingResponse with text/event-stream content type and proper event framing)",
              "Request/response validation via Pydantic models",
              "Authentication via dependency injection",
              "Rate limiting per user",
              "CORS middleware for future API clients",
              "Automatic OpenAPI documentation"
            ],
            "rationale": "FastAPI provides async support for concurrent LLM calls, automatic Pydantic validation, and built-in OpenAPI docs. Dependency injection simplifies auth and database session management. Uvicorn ASGI server handles SSE streaming efficiently. SSE implemented via FastAPI StreamingResponse with text/event-stream content type and proper event framing (data: prefix, double newline delimiters). Python's async/await syntax simplifies concurrent operations.",
            "import_pattern": "from app.routers import repo_view, workspace"
          }
        },
        {
          "id": "component-orchestration",
          "type": "component",
          "data": {
            "name": "Orchestration Core",
            "technology": "Python + asyncio",
            "location": "app/services/orchestrator_core.py",
            "responsibilities": [
              "Finite state machine for pipeline stages (pm_questions → epic_approval → architecture_start → architecture_approval → ba_start → backlog_approval)",
              "Agent dispatcher: spawns 3 agents in parallel via asyncio.gather",
              "Approval gate manager: pauses pipeline until user approves or rejects",
              "Re-run coordinator: fetches Epic/Architecture from canonical_documents and replays stage",
              "Error handler: implements retry with exponential backoff",
              "Context management: stores user inputs in pipeline_state.context (JSON)"
            ],
            "rationale": "Python's asyncio enables concurrent agent execution without threading complexity. Finite state machine prevents invalid transitions. Orchestration Core implemented as pure Python module (no FastAPI dependencies). FastAPI routes act as thin adapters that call orchestrator functions. This separation enables unit testing without web stack and future extraction to worker processes if async job queues are needed in later phases.",
            "import_pattern": "from app.services.orchestrator_core import OrchestratorCore"
          }
        },
        {
          "id": "component-agent",
          "type": "component",
          "data": {
            "name": "Agent Service",
            "technology": "anthropic Python SDK (AsyncAnthropic)",
            "location": "app/services/pm_agent_service.py, app/services/architecture_agent_service.py, app/services/backlog_agent_service.py",
            "responsibilities": [
              "Async API calls to Anthropic Claude API via anthropic.AsyncAnthropic",
              "Model configuration: claude-sonnet-4-20250514 (hardcoded for MVP)",
              "Prompt management: loads from file-based prompt library",
              "Streaming response handler: yields tokens to SSE endpoint",
              "Retry logic: multiple attempts with exponential backoff on API failures",
              "Token usage logging: captures tokens_used for cost tracking in agent_logs table",
              "Response parsing: validates agent output against expected schemas"
            ],
            "rationale": "Official Anthropic SDK provides async support and streaming API. File-based prompts enable version control and updates without code changes. Token logging enables cost monitoring (critical for subscription pricing model). Retry logic handles transient API failures without user intervention. Streaming responses provide real-time feedback to users during long-running operations.",
            "import_pattern": "from app.services.pm_agent_service import PMAgentService"
          }
        },
        {
          "id": "component-validation",
          "type": "component",
          "data": {
            "name": "Schema Validation Layer",
            "technology": "Pydantic + Custom Validators",
            "location": "app/schemas/",
            "responsibilities": [
              "CanonicalArchitectureV1 Pydantic model enforces: fixed section keys, block type validation, no extra keys (extra='forbid')",
              "Block-level validation: paragraph, heading, code, list_item, component, entity, decision, risk, table, key_value",
              "Custom validators: block ID uniqueness per section, table row length matches headers, risk likelihood/impact enums",
              "Pre-save validation: all canonical documents validated before INSERT into database",
              "Mentor rewrite loop: if validation fails, Architect Mentor rewrites until valid",
              "Schema versioning: schema_version field enables future migrations"
            ],
            "rationale": "Pydantic provides runtime schema enforcement that mirrors JSON Schema specification. Custom validators catch complex constraints (ID uniqueness, table consistency). Pre-save validation prevents corrupt data from entering canonical store. Schema versioning enables backward compatibility when schemas evolve in later phases. Validation errors provide detailed feedback for debugging and mentor rewriting.",
            "import_pattern": "from app.schemas.canonical_architecture import CanonicalArchitectureV1"
          }
        },
        {
          "id": "component-storage",
          "type": "component",
          "data": {
            "name": "Canonical Document Store",
            "technology": "SQLite (MVP) / PostgreSQL (Phase 2+) + SQLAlchemy ORM",
            "location": "experience/workbench.db (database file), app/models/ (ORM models)",
            "responsibilities": [
              "Durable storage for workspaces, canonical documents, pipeline state, agent logs",
              "JSON column for canonical_documents.content (validated schemas)",
              "Status tracking: draft / approved / superseded (enables soft versioning)",
              "SQLAlchemy ORM provides database-agnostic queries (SQLite → PostgreSQL migration requires only connection string change)",
              "Indexes on workspace_id, doc_type, status for fast queries",
              "Foreign key constraints enforce referential integrity"
            ],
            "rationale": "SQLite provides zero-configuration persistence for MVP (suitable for hundreds of concurrent users). JSON column support stores validated canonical documents. SQLAlchemy ORM abstracts database differences, enabling seamless PostgreSQL migration when scale requires it (no application code changes). Soft versioning (status field) prepares for version history feature without schema changes. Foreign key constraints prevent orphaned records.",
            "import_pattern": "from app.models.workspace import Workspace"
          }
        },
        {
          "id": "component-export",
          "type": "component",
          "data": {
            "name": "Export Service",
            "technology": "Jinja2 Templates + Python JSON Serialization",
            "location": "app/services/export_service.py",
            "responsibilities": [
              "Markdown export: reads canonical_documents.content → applies Jinja2 template → generates .md file",
              "JSON export: serializes canonical document with Jira-compatible metadata (Epic → Feature → Story traceability)",
              "Derives from canonical store: never regenerates content from scratch",
              "Local filesystem storage with time-limited retention",
              "Download endpoints: GET /workspaces/{id}/export?format=markdown|json"
            ],
            "rationale": "Template-based generation ensures consistent formatting. Deriving from canonical store (not regenerating) guarantees exports match approved artifacts. Local filesystem avoids cloud storage costs and complexity for MVP. Jinja2 templates enable customization without code changes. Time-limited retention acceptable because exports are ephemeral (users download immediately). Future migration to cloud storage requires only storage backend abstraction.",
            "import_pattern": "from app.services.export_service import ExportService"
          }
        },
        {
          "id": "component-repo-view",
          "type": "component",
          "data": {
            "name": "Repository View Service",
            "technology": "Python pathlib + FastAPI",
            "location": "app/services/repo_reader.py, app/routers/repo_view.py",
            "responsibilities": [
              "Read-only file system introspection for AI Dev Orchestrator",
              "Strict allow-list enforcement (app, templates, tests, static, pyproject.toml, README.md)",
              "Forbidden path blocking (.env, .git, __pycache__, secrets) with case-insensitive matching",
              "Binary file exclusion (.pyc, .db, .sqlite, images, etc.)",
              "Glob pattern support for filtering (e.g., **/*.py)",
              "Path traversal attack prevention",
              "Project root derivation from file location (not cwd)"
            ],
            "rationale": "Enables AI agents to discover project structure before making code changes. Strict security model prevents exposure of secrets or sensitive files. Read-only design eliminates risk of file corruption. Pathlib provides cross-platform path handling. Allow-list approach (not deny-list) ensures safe-by-default behavior.",
            "import_pattern": "from app.services.repo_reader import repo_reader"
          }
        }
      ]
    },
    "data_model": {
      "blocks": [
        {
          "id": "data-intro",
          "type": "paragraph",
          "content": "The data model uses SQLAlchemy ORM with SQLite for MVP and PostgreSQL-ready schema design. The canonical_documents table is the authoritative store for all validated artifacts (Epics, Architectures, Backlogs), with JSON columns storing schema-compliant documents. Database file location: experience/workbench.db. All ORM models located in app/models/."
        },
        {
          "id": "schema-registry",
          "type": "paragraph",
          "content": "The system defines multiple canonical document schemas, all stored in the canonical_documents table with schema validation via corresponding Pydantic models: CanonicalArchitectureV1 (doc_type='architecture'), CanonicalEpicV1 (doc_type='epic'), CanonicalBacklogV1 (doc_type='backlog'), PMQuestionsV1 (doc_type='pm_questions'). All schemas follow the pattern: {type, version, sections} with section-specific block structures. Each schema has a corresponding Pydantic model for validation."
        },
        {
          "id": "entity-workspaces",
          "type": "entity",
          "data": {
            "name": "workspaces",
            "location": "app/models/workspace.py",
            "fields": [
              {
                "name": "id",
                "type": "TEXT PRIMARY KEY",
                "description": "UUID as string"
              },
              {
                "name": "user_id",
                "type": "TEXT NOT NULL",
                "description": "User identifier"
              },
              {
                "name": "name",
                "type": "TEXT NOT NULL",
                "description": "Workspace name"
              },
              {
                "name": "description",
                "type": "TEXT",
                "description": "Workspace description"
              },
              {
                "name": "status",
                "type": "TEXT NOT NULL DEFAULT 'active'",
                "description": "active | archived | deleted"
              },
              {
                "name": "created_at",
                "type": "TEXT NOT NULL",
                "description": "ISO 8601 timestamp"
              },
              {
                "name": "updated_at",
                "type": "TEXT NOT NULL",
                "description": "ISO 8601 timestamp"
              }
            ],
            "relationships": [
              "One-to-many with canonical_documents",
              "One-to-one with pipeline_state",
              "One-to-many with agent_logs"
            ],
            "indexes": [
              "user_id (for user workspace queries)"
            ]
          }
        },
        {
          "id": "entity-canonical-documents",
          "type": "entity",
          "data": {
            "name": "canonical_documents",
            "location": "app/models/canonical_documents.py",
            "fields": [
              {
                "name": "id",
                "type": "TEXT PRIMARY KEY",
                "description": "UUID as string"
              },
              {
                "name": "workspace_id",
                "type": "TEXT NOT NULL REFERENCES workspaces(id)",
                "description": "Parent workspace"
              },
              {
                "name": "doc_type",
                "type": "TEXT NOT NULL",
                "description": "epic | architecture | backlog | pm_questions"
              },
              {
                "name": "status",
                "type": "TEXT NOT NULL",
                "description": "draft | approved | superseded"
              },
              {
                "name": "schema_version",
                "type": "INTEGER NOT NULL",
                "description": "e.g., 1 for CanonicalArchitectureV1"
              },
              {
                "name": "content",
                "type": "JSON NOT NULL",
                "description": "Validated canonical document"
              },
              {
                "name": "created_at",
                "type": "TEXT NOT NULL",
                "description": "ISO 8601 timestamp"
              },
              {
                "name": "updated_at",
                "type": "TEXT NOT NULL",
                "description": "ISO 8601 timestamp"
              }
            ],
            "relationships": [
              "Belongs to workspace"
            ],
            "indexes": [
              "workspace_id (for workspace document queries)",
              "doc_type + status (for current document queries)",
              "created_at (for version history)"
            ]
          }
        },
        {
          "id": "entity-pipeline-state",
          "type": "entity",
          "data": {
            "name": "pipeline_state",
            "location": "app/models/pipeline_state.py",
            "fields": [
              {
                "name": "id",
                "type": "TEXT PRIMARY KEY",
                "description": "UUID as string"
              },
              {
                "name": "workspace_id",
                "type": "TEXT NOT NULL UNIQUE REFERENCES workspaces(id)",
                "description": "Parent workspace (one-to-one)"
              },
              {
                "name": "stage",
                "type": "TEXT NOT NULL",
                "description": "pm_questions | awaiting_user_answers | epic_approval | architecture_start | etc."
              },
              {
                "name": "approved",
                "type": "INTEGER NOT NULL DEFAULT 0",
                "description": "boolean: 0 or 1"
              },
              {
                "name": "context",
                "type": "JSON",
                "description": "User inputs, intermediate state for re-runs"
              },
              {
                "name": "created_at",
                "type": "TEXT NOT NULL",
                "description": "ISO 8601 timestamp"
              },
              {
                "name": "updated_at",
                "type": "TEXT NOT NULL",
                "description": "ISO 8601 timestamp"
              }
            ],
            "relationships": [
              "Belongs to workspace (one-to-one)"
            ],
            "indexes": []
          }
        },
        {
          "id": "entity-agent-logs",
          "type": "entity",
          "data": {
            "name": "agent_logs",
            "location": "app/models/agent_logs.py",
            "fields": [
              {
                "name": "id",
                "type": "TEXT PRIMARY KEY",
                "description": "UUID as string"
              },
              {
                "name": "workspace_id",
                "type": "TEXT NOT NULL REFERENCES workspaces(id)",
                "description": "Parent workspace"
              },
              {
                "name": "role",
                "type": "TEXT NOT NULL",
                "description": "pm | architect | ba | pm_mentor | architect_mentor | ba_mentor"
              },
              {
                "name": "stage",
                "type": "TEXT NOT NULL",
                "description": "Pipeline stage when invoked"
              },
              {
                "name": "prompt",
                "type": "TEXT",
                "description": "System prompt + user input"
              },
              {
                "name": "response",
                "type": "TEXT",
                "description": "Agent output"
              },
              {
                "name": "tokens_used",
                "type": "INTEGER",
                "description": "For cost tracking"
              },
              {
                "name": "duration_ms",
                "type": "INTEGER",
                "description": "For performance monitoring"
              },
              {
                "name": "error",
                "type": "TEXT",
                "description": "Captures failures"
              },
              {
                "name": "created_at",
                "type": "TEXT NOT NULL",
                "description": "ISO 8601 timestamp"
              }
            ],
            "relationships": [
              "Belongs to workspace"
            ],
            "indexes": [
              "workspace_id + created_at (for chronological log queries)",
              "role + stage (for agent performance analysis)"
            ]
          }
        },
        {
          "id": "data-notes",
          "type": "paragraph",
          "content": "The canonical_documents table is the single source of truth. All downstream operations (BA story generation, exports) read from this table. Schema validation via Pydantic occurs before INSERT. Status field enables soft versioning: approved documents are current, superseded documents are historical, draft documents are pending approval. SQLite database file (workbench.db) is located in the experience/ directory (project root). All file paths in code must be relative to the project root or use absolute paths derived from Path(__file__).resolve() with explicit parents[N] traversal to reach experience/. SQLite to PostgreSQL migration path: SQLAlchemy ORM enables database-agnostic queries. To migrate, update connection string and run schema migration. PostgreSQL JSONB columns replace SQLite JSON columns, enabling GIN indexes for faster JSON queries. No application code changes required."
        }
      ]
    },
    "key_decisions": {
      "blocks": [
        {
          "id": "decision-python-fastapi",
          "type": "decision",
          "data": {
            "title": "Python + FastAPI Backend",
            "decision": "Use Python with FastAPI framework for backend API",
            "alternatives": [
              "Node.js + Express or NestJS",
              "Go + Gin or Fiber"
            ],
            "rationale": [
              "FastAPI provides async/await support for concurrent LLM calls via asyncio.gather",
              "Native Pydantic integration enables automatic request/response validation and matches schema validation requirements",
              "Anthropic Python SDK is official and provides async streaming support",
              "Python ecosystem simplifies schema validation (Pydantic mirrors JSON Schema patterns)",
              "Automatic OpenAPI documentation generation reduces API documentation overhead",
              "Simpler async syntax for concurrent operations compared to callback-based approaches"
            ],
            "tradeoffs": [
              "Python's GIL limits CPU-bound parallelism, but not relevant for I/O-bound LLM API calls",
              "FastAPI's async I/O handles concurrency effectively for MVP scale",
              "Performance sufficient for target load of hundreds of concurrent users"
            ]
          }
        },
        {
          "id": "decision-ssr-htmx",
          "type": "decision",
          "data": {
            "title": "Server-Side Rendering with HTMX",
            "decision": "Use server-side rendering (Jinja2) with HTMX for dynamic interactions",
            "alternatives": [
              "React + Vite SPA",
              "Vue.js or Svelte SPA"
            ],
            "rationale": [
              "Eliminates build pipeline complexity (no package managers, bundlers, transpilers)",
              "HTMX provides SPA-like interactions with minimal JavaScript payload",
              "Server controls all state, eliminating client-side state management libraries",
              "Faster initial page loads (no large JavaScript bundle download)",
              "Simplified debugging (HTML returned from server, not client-rendered)",
              "Lower operational complexity (no separate frontend/backend deployments)"
            ],
            "tradeoffs": [
              "Less responsive than full SPA (some full-page reloads)",
              "Acceptable for linear workflow (submit idea → approve stages → export)",
              "Users tolerate minor UX trade-off for faster MVP delivery and simpler architecture"
            ]
          }
        },
        {
          "id": "decision-sqlite",
          "type": "decision",
          "data": {
            "title": "SQLite for MVP with PostgreSQL Migration Path",
            "decision": "Use SQLite for MVP with clear PostgreSQL migration path",
            "alternatives": [
              "PostgreSQL from day 1",
              "MongoDB or other document databases"
            ],
            "rationale": [
              "SQLite provides zero-configuration persistence (file-based, no separate database server)",
              "JSON column support stores validated canonical documents",
              "Sufficient for MVP scale (hundreds of concurrent users with read-heavy workload)",
              "SQLAlchemy ORM abstracts database differences (migration requires only connection string change)",
              "Eliminates managed database costs for MVP",
              "Faster local development (no database server setup)"
            ],
            "tradeoffs": [
              "SQLite has concurrent write limitations and lacks advanced JSON indexing (PostgreSQL GIN indexes)",
              "Migration to PostgreSQL required when exceeding hundreds of concurrent users or needing complex JSON queries",
              "Migration path is straightforward via SQLAlchemy abstraction"
            ]
          }
        },
        {
          "id": "decision-canonical-store",
          "type": "decision",
          "data": {
            "title": "Canonical Document Store as Single Source of Truth",
            "decision": "Store all validated artifacts in canonical_documents table; all downstream operations read from this table",
            "alternatives": [
              "Regenerate artifacts from agent outputs on-demand",
              "Store raw agent outputs and validate on read"
            ],
            "rationale": [
              "Schema validation (Pydantic) occurs before INSERT, preventing corrupt data from entering system",
              "Downstream phases (BA, Export) operate ONLY on validated canonical documents, ensuring consistency",
              "Traceability: all approved artifacts versioned via status field (draft/approved/superseded)",
              "Human + machine readable: JSON structure enables both API consumption and template-based rendering",
              "Audit trail: agent_logs table preserves raw agent outputs for debugging and analysis"
            ],
            "tradeoffs": [
              "Requires strict schema enforcement and validation logic",
              "Mentor agents must rewrite proposals until they pass schema validation",
              "Adds processing time but ensures data quality and consistency across all phases"
            ]
          }
        },
        {
          "id": "decision-pydantic",
          "type": "decision",
          "data": {
            "title": "Pydantic Schema Enforcement for All Canonical Documents",
            "decision": "Use Pydantic models to enforce all canonical document schemas (CanonicalArchitectureV1, CanonicalEpic, CanonicalBacklog)",
            "alternatives": [
              "JSON Schema validation via external library",
              "Manual validation logic"
            ],
            "rationale": [
              "Pydantic provides runtime schema enforcement that mirrors JSON Schema specification",
              "extra='forbid' configuration prevents unknown keys at all levels (root, sections, blocks, data objects)",
              "Custom validators handle complex constraints (block ID uniqueness, table row consistency, enum validation)",
              "Type hints provide IDE autocomplete and enable static type checking during development",
              "Native FastAPI integration enables automatic API request/response validation and documentation"
            ],
            "tradeoffs": [
              "Pydantic validation adds processing overhead, but negligible compared to LLM API latency",
              "Schema evolution requires Pydantic model updates, but schema_version field enables backward compatibility and gradual migrations"
            ]
          }
        },
        {
          "id": "decision-asyncio",
          "type": "decision",
          "data": {
            "title": "Synchronous Orchestration via Asyncio",
            "decision": "Use Python asyncio.gather for concurrent agent execution; no separate job queue system",
            "alternatives": [
              "Background job queue (Celery, RQ) with message broker",
              "Threading or multiprocessing"
            ],
            "rationale": [
              "asyncio.gather spawns 3 agents in parallel with straightforward code",
              "Non-blocking I/O for LLM API calls (most time spent waiting for network responses)",
              "Acceptable latency for synchronous execution (per Epic acceptance criteria)",
              "Eliminates operational complexity (no message broker, worker processes, or job monitoring)",
              "Simpler error handling (exceptions raised in same execution context)"
            ],
            "tradeoffs": [
              "User must wait for pipeline completion (no background jobs)",
              "API endpoint blocks until agents finish",
              "Acceptable for MVP given latency targets and conversational UI expectations",
              "Can migrate to job queue in later phases if requirements change"
            ]
          }
        },
        {
          "id": "decision-filesystem",
          "type": "decision",
          "data": {
            "title": "Local Filesystem for Export Storage",
            "decision": "Store exports in local filesystem with time-limited retention; no cloud storage",
            "alternatives": [
              "Cloud object storage (AWS S3, GCS, Azure Blob) from day 1"
            ],
            "rationale": [
              "Exports are ephemeral (users download immediately, no long-term storage requirement)",
              "Derived from canonical documents (not regenerated), ensures consistency",
              "Zero cost compared to cloud storage fees",
              "Simpler deployment (no cloud credentials or SDK integration)",
              "Time-limited retention sufficient for MVP usage patterns"
            ],
            "tradeoffs": [
              "Local filesystem not horizontally scalable (exports tied to specific container instance)",
              "Migration to cloud storage required when deploying multiple instances in later phases",
              "Migration straightforward via storage backend abstraction pattern"
            ]
          }
        },
        {
          "id": "decision-package-structure",
          "type": "decision",
          "data": {
            "title": "Canonical Package Structure (app/ as Python Package)",
            "decision": "Treat experience/ as project root and app/ as canonical Python package with all application code",
            "alternatives": [
              "Flat structure with main.py in experience/ root",
              "Nested experience.app package structure"
            ],
            "rationale": [
              "Enables clean absolute imports: from app.routers import repo_view (not from experience.app.routers)",
              "FastAPI entrypoint at app/main.py maintains package boundaries and namespace isolation",
              "Working directory (experience/) establishes app/ as importable top-level package via sys.path",
              "Consistent module resolution across development (uvicorn), testing (pytest), and production",
              "Prevents relative import complexity and circular dependency issues"
            ],
            "tradeoffs": [
              "Requires cd experience before all commands (uvicorn, pytest, scripts)",
              "Developers must understand working directory affects module resolution",
              "Docker containers must set WORKDIR to /app/experience for same behavior"
            ]
          }
        }
      ]
    },
    "non_functional_requirements": {
      "blocks": [
        {
          "id": "nfr-performance",
          "type": "paragraph",
          "content": "Performance: Architecture generation completes within Epic acceptance criteria via parallel agent execution using asyncio.gather. Ad-hoc Q&A responses complete within Epic acceptance criteria using single agent calls. Export generation is fast via template rendering from canonical JSON. Schema validation has minimal overhead via Pydantic validation. Database queries are optimized via indexes on workspace_id, doc_type, and status fields."
        },
        {
          "id": "nfr-scalability",
          "type": "paragraph",
          "content": "Scalability (MVP): Target of 750 active users per Epic requirements. Workload of 3-4 ideas per user per month per Epic requirements. LLM API calls volume determined by workflow design (multiple agents per stage). SQLite capacity suitable for hundreds of concurrent users with read-heavy workload. Single FastAPI instance handles target load via async I/O (non-blocking). PostgreSQL migration trigger: exceeding hundreds of concurrent users or complex JSON query requirements."
        },
        {
          "id": "nfr-cost",
          "type": "paragraph",
          "content": "Cost Structure (MVP): LLM API (Anthropic) is primary cost driver based on workflow token usage ($1,875-3,750/month). Infrastructure via managed container platform with SQLite has minimal cost ($15-40/month). Export storage via local filesystem has zero additional cost. Total costs dominated by LLM API usage per workflow (<$4,000/month). Revenue target of $21,750/month ($29/month × 750 users). Gross Margin of 45-75% per Epic financial targets. Unit Economics: Infrastructure costs minimized via SQLite and single container deployment. Cost structure enables healthy margins per Epic financial model. LLM API costs scale linearly with usage, requiring monitoring and alerting."
        },
        {
          "id": "nfr-security",
          "type": "paragraph",
          "content": "Security: Authentication via magic link with session tokens stored in sessions table, verified via FastAPI dependency injection. Authorization via row-level security using SQLAlchemy filters (all queries scoped to user_id). SQL Injection prevented via SQLAlchemy parameterized queries (no raw SQL execution). Rate Limiting per-user request rate limiting to prevent abuse. Secret Management via environment variables for sensitive configuration (no secrets in code). HTTPS enforced via managed platform (automatic TLS certificate management). Repository introspection security via strict allow-list (app, templates, tests, static, pyproject.toml, README.md) and forbidden path blocking (.env, .git, __pycache__, secrets)."
        },
        {
          "id": "nfr-observability",
          "type": "paragraph",
          "content": "Monitoring & Observability: Logging via agent_logs table captures all LLM interactions (prompt, response, tokens, duration, errors). Log Format uses structured logging for parsing and analysis. Retention via time-based retention policy in agent_logs table. Metrics (Phase 2) via metrics endpoint for time-to-architecture, agent failure rates, cost per workflow. Error Tracking via error capture and reporting integration. Health Check via health endpoint for platform monitoring."
        }
      ]
    },
    "deployment": {
      "blocks": [
        {
          "id": "deploy-diagram",
          "type": "code",
          "language": "text",
          "content": "┌────────────────────────────────────────────┐\n│           User Browser                     │\n│   (HTML + HTMX + EventSource)              │\n└─────────────────┬──────────────────────────┘\n                  │ HTTPS (TLS)\n                  │\n┌─────────────────▼──────────────────────────┐\n│       Managed Container Platform           │\n│                                            │\n│  ┌──────────────────────────────────────┐ │\n│  │   Docker Container                   │ │\n│  │   WORKDIR: /app/experience           │ │\n│  │                                      │ │\n│  │  ┌────────────────────────────────┐ │ │\n│  │  │  FastAPI Application           │ │ │\n│  │  │  (app/main.py)                 │ │ │\n│  │  │  - API endpoints               │ │ │\n│  │  │  - SSE streaming               │ │ │\n│  │  │  - Template rendering          │ │ │\n│  │  └────────────────────────────────┘ │ │\n│  │                                      │ │\n│  │  ┌────────────────────────────────┐ │ │\n│  │  │  SQLite Database               │ │ │\n│  │  │  (Persistent Volume)           │ │ │\n│  │  │  Location: workbench.db        │ │ │\n│  │  └────────────────────────────────┘ │ │\n│  │                                      │ │\n│  │  app/ (Python package)              │ │\n│  │  templates/ (Jinja2 HTML)           │ │\n│  │  static/ (CSS, JS, images)          │ │\n│  └──────────────────────────────────────┘ │\n│                                            │\n│  Anthropic API (HTTPS) ────────────────────→\n└────────────────────────────────────────────┘"
        },
        {
          "id": "deploy-dockerfile",
          "type": "code",
          "language": "dockerfile",
          "content": "FROM python:3.12-slim\n\nWORKDIR /app\n\n# Copy project files\nCOPY experience/ /app/experience/\n\n# Set working directory to experience/ (canonical execution context)\nWORKDIR /app/experience\n\n# Install dependencies\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Expose port\nEXPOSE 8000\n\n# Run uvicorn with canonical app path\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]"
        },
        {
          "id": "deploy-hosting",
          "type": "paragraph",
          "content": "Hosting Platforms: Container via single Docker image containing FastAPI application, prompts, and templates. Platform via managed container platform with Docker support and persistent volumes. Database via SQLite file on persistent volume. TLS/HTTPS automatic via platform (managed certificate provisioning). Domain with custom domain support."
        },
        {
          "id": "deploy-environments",
          "type": "paragraph",
          "content": "Environments: Development uses local environment with hot-reloading for rapid iteration (cd experience; uvicorn app.main:app --reload). Staging uses platform preview environment (auto-created on pull requests, isolated database). Production uses platform production environment (main branch auto-deploy)."
        },
        {
          "id": "deploy-cicd",
          "type": "paragraph",
          "content": "CI/CD Pipeline: Git push to main branch triggers deployment. Platform builds Docker image automatically. Image deployed to container runtime (zero downtime via health checks). Database migrations via schema migration tool runs on container startup."
        }
      ]
    },
    "tech_stack_summary": {
      "blocks": [
        {
          "id": "tech-stack-table",
          "type": "table",
          "data": {
            "headers": [
              "Layer",
              "Technology",
              "Justification"
            ],
            "rows": [
              [
                "Frontend",
                "Jinja2 + HTMX + Tailwind CSS",
                "Server-side rendering, minimal JS, no build step"
              ],
              [
                "API",
                "FastAPI + Pydantic",
                "Async, automatic validation, OpenAPI docs"
              ],
              [
                "ORM",
                "SQLAlchemy",
                "Database-agnostic (SQLite → PostgreSQL)"
              ],
              [
                "Database",
                "SQLite (MVP) / PostgreSQL (Phase 2+)",
                "Zero-config → production-ready"
              ],
              [
                "LLM",
                "anthropic Python SDK",
                "Official SDK, async support, streaming"
              ],
              [
                "Validation",
                "Pydantic",
                "Schema enforcement, canonical document validation"
              ],
              [
                "Streaming",
                "Server-Sent Events",
                "Unidirectional, HTTP-based, EventSource API"
              ],
              [
                "Authentication",
                "Magic link (Phase 1)",
                "Email-only, session-based, no third-party providers"
              ],
              [
                "Rate Limiting",
                "Per-user rate limiting",
                "Prevent abuse and control costs"
              ],
              [
                "Deployment",
                "Docker + Managed Platform",
                "Single container, automated deployment"
              ],
              [
                "Export Storage",
                "Local Filesystem",
                "Zero cost, time-limited retention"
              ]
            ]
          }
        }
      ]
    },
    "roadmap_implications": {
      "blocks": [
        {
          "id": "roadmap-phase1",
          "type": "paragraph",
          "content": "Phase 1: Core Platform / MVP (Months 1-3) - Architecture fully supports Phase 1 requirements with Python/FastAPI stack: Orchestration engine via Python asyncio finite state machine for PM → Architect → BA pipeline. Approval gates via FastAPI endpoints pause pipeline at Epic, Architecture, Backlog stages. Basic artifact editing via HTMX forms submit updates to canonical_documents table. Manual stage re-run via API reads Epic from canonical_documents and replays Architect agents. Export service via template rendering from canonical JSON, direct JSON serialization. Ad-hoc Q&A via SSE endpoint streams single agent response to user queries. Repository introspection via read-only API (REPO-100, REPO-101) enables AI Dev Orchestrator to discover project structure."
        },
        {
          "id": "roadmap-phase2",
          "type": "paragraph",
          "content": "Phase 2: Workflow Intelligence (Months 4-6) - Architecture prepares for Phase 2 features with minimal changes: Drift Detection via compare canonical_documents versions (status='approved' vs. 'superseded'), flag conflicts in UI. Version History via query canonical_documents WHERE status='superseded' ORDER BY created_at DESC for rollback UI. Idea Library via add full-text search on workspaces.name + description via database full-text search capabilities. PDF Export via add PDF generation library, render template to PDF format. PostgreSQL Migration via update connection string, run schema migration tool. Repository content search (REPO-200) adds grep-like functionality for AI agents to find implementations."
        },
        {
          "id": "roadmap-phase3",
          "type": "paragraph",
          "content": "Phase 3: Growth & Expansion (Months 7-9) - Architecture supports Phase 3 scaling with moderate refactoring: Multi-User (Read-Only) via add workspace_shares table with permission field, query filters for shared access. API Access via add api_keys table, API key authentication, expose REST endpoints for programmatic access. User-Selectable Models via add model_config JSON field to workspaces, Agent Service reads configuration. Horizontal Scaling via deploy multiple FastAPI containers behind load balancer, shared PostgreSQL database. Cloud Storage Migration via replace local filesystem with cloud object storage, environment variable toggles backend."
        }
      ]
    },
    "risks_and_mitigations": {
      "blocks": [
        {
          "id": "risk-llm-api",
          "type": "risk",
          "data": {
            "risk": "LLM API Instability",
            "likelihood": "Medium",
            "impact": "High",
            "description": "Anthropic Claude API may experience downtime, rate limiting, or inconsistent output quality, blocking user workflows.",
            "mitigation": [
              "Retry logic with exponential backoff for transient failures",
              "User notification on final failure with retry option",
              "agent_logs table captures all errors for debugging (prompt, response, error field)",
              "Phase 2: Add response caching for common questions to reduce API dependency"
            ]
          }
        },
        {
          "id": "risk-cost-overrun",
          "type": "risk",
          "data": {
            "risk": "Cost Overrun (LLM Usage)",
            "likelihood": "Medium",
            "impact": "High",
            "description": "Users generate excessive workflows, driving LLM costs above revenue targets.",
            "mitigation": [
              "Per-user workflow limits enforced in pipeline_state queries",
              "Token usage monitoring via agent_logs.tokens_used field enables cost dashboards",
              "Alert when monthly cost exceeds budget threshold",
              "Future: Usage-based pricing tiers or workflow limits per subscription level"
            ]
          }
        },
        {
          "id": "risk-schema-validation",
          "type": "risk",
          "data": {
            "risk": "Schema Validation Failures",
            "likelihood": "Medium",
            "impact": "Medium",
            "description": "Mentor agents produce outputs that fail canonical schema validation, blocking pipeline progression.",
            "mitigation": [
              "Mentor rewrite loop: If Pydantic validation fails, Mentor receives error details and regenerates",
              "Maximum rewrite attempts before escalating to user with error message",
              "Detailed validation errors logged to agent_logs.error for debugging",
              "Phase 2: Refine Mentor prompts based on validation failure patterns"
            ]
          }
        },
        {
          "id": "risk-sqlite-limits",
          "type": "risk",
          "data": {
            "risk": "SQLite Concurrent Write Limits",
            "likelihood": "Low",
            "impact": "Medium",
            "description": "SQLite has concurrent write limitations that may cause errors under heavy concurrent load.",
            "mitigation": [
              "Acceptable for MVP scale with read-heavy workload pattern",
              "Database connection pooling and write-ahead logging improve concurrency",
              "Monitor database errors in logs, trigger PostgreSQL migration if error rate exceeds threshold",
              "PostgreSQL migration ready via SQLAlchemy abstraction"
            ]
          }
        },
        {
          "id": "risk-slow-generation",
          "type": "risk",
          "data": {
            "risk": "Slow Architecture Generation",
            "likelihood": "Low",
            "impact": "Medium",
            "description": "Pipeline exceeds target latency due to LLM response times or network issues.",
            "mitigation": [
              "Parallel agent execution: asyncio.gather spawns 3 agents concurrently",
              "Optimize prompts to reduce token count (fewer input tokens = faster response)",
              "Monitor agent_logs.duration_ms to identify performance bottlenecks",
              "Phase 3: If persistent issues, migrate to async job queue for background processing"
            ]
          }
        },
        {
          "id": "risk-data-loss",
          "type": "risk",
          "data": {
            "risk": "Data Loss (User Edits)",
            "likelihood": "Low",
            "impact": "High",
            "description": "User loses work due to database corruption, accidental deletion, or application bugs.",
            "mitigation": [
              "Soft deletes: status='superseded' prevents hard deletion of canonical_documents",
              "Automated database backups via platform or scheduled jobs",
              "Transaction isolation: Database sessions with COMMIT on success, ROLLBACK on error",
              "Phase 2: Version history UI enables rollback to any approved checkpoint"
            ]
          }
        }
      ]
    },
    "deprecated_patterns": {
      "blocks": [
        {
          "id": "deprecated-patterns-overview",
          "type": "paragraph",
          "content": "The following patterns were used in early development but are now deprecated and must not appear in new code. Existing code using these patterns should be refactored during the next relevant story."
        },
        {
          "id": "deprecated-patterns-list",
          "type": "list_item",
          "content": "DEPRECATED: main.py in experience/ root (now: app/main.py). DEPRECATED: from experience.app.* imports (now: from app.* imports). DEPRECATED: Running uvicorn main:app from experience/ (now: uvicorn app.main:app). DEPRECATED: Deriving project_root from Path.cwd() (now: derive from Path(__file__) with explicit parents[N] traversal). DEPRECATED: Treating experience/ as a Python package with __init__.py (now: experience/ is project root only, not a package)."
        },
        {
          "id": "deprecated-patterns-migration",
          "type": "paragraph",
          "content": "Migration path: For code currently using deprecated patterns, apply these transformations: (1) Move any main.py from experience/main.py to app/main.py. (2) Update all from experience.app.* imports to from app.* imports. (3) Update uvicorn commands to use app.main:app. (4) Update any Path(__file__).resolve().parents[N] logic to account for new structure (e.g., repo_reader.py is now at app/services/repo_reader.py, so project root is parents[2])."
        }
      ]
    },
    "out_of_scope": {
      "blocks": [
        {
          "id": "out-of-scope-list",
          "type": "list_item",
          "content": "Per Epic requirements, the following features are NOT included in MVP: Client-side SPA frameworks (React, Vue, Svelte), Microservices architecture, Background job queues (Celery, RQ, Redis-based systems), Drift detection and resync UI (Phase 2), Version history with rollback UI (Phase 2), Idea library with search and indexing (Phase 2), PDF export generation (Phase 2), Multi-user real-time collaboration (Phase 3), Bi-directional Jira/Linear sync (Phase 3), User-editable agent prompts or custom agents (Phase 3+), Mobile native apps (web-responsive UI only)."
        }
      ]
    }
  }
}